<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom"><title>SIGUSR2</title><link href="http://sigusr2.net/atom.xml" rel="self" /><link href="http://sigusr2.net/"/><updated>2011-04-18T07:15:17Z</updated><author><name>Andrew Gwozdziewycz</name></author><id>md5:ec2c8804a8dac6a866e1a43cfce32fc1</id><entry><title>Parser Combinators Made Simple</title><link href="http://sigusr2.net/2011/Apr/18/parser-combinators-made-simple.html"/><id>md5:2d4da36bd3daa6959e8b4f79b8094fc4</id><updated>2011-04-18T00:00:00Z</updated><content type="html"><![CDATA[<p><span class="preamble">Parsing theory has been around for quite a long time, but it is often thought of as magic by the swarms of people who haven't bothered to read about it, and see how plain and dry it actually is. Algorithms for parsing <a href="http://en.wikipedia.org/wiki/LR_parser">LR(k)</a> grammars (meaning Left-to-right, Right-most derivation, k tokens lookahead) for instance, normally just traverse a state machine that was computed before hand (either by hand, or by using a parser generator such as <a href="http://www.gnu.org/software/bison/">bison</a> or <a href="http://en.wikipedia.org/wiki/Yacc">yacc</a>). Sure, there are many things to trip on, tedious to track down ambiguities, and other issues, but the general theory of parsing has remained unchanged for years&mdash;one might say, it is a solved problem.<sup><a id="return-solvedproblem" href="#note-solvedproblem">[1]</a></span></p>

<p>When learning about parsing for the first time though, the idea of a <a href="http://en.wikipedia.org/wiki/Recursive_descent_parser">recursive descent parser</a> is often taught first. Recursive descent parsers, are relatively simple to reason about, to write and to shoot yourself in the foot with. A simple <a href="http://en.wikipedia.org/wiki/LL_parser">LL(1)</a> parser (meaning Left-to-right, Left-most derivation, 1 token lookahead), for instance, can't parse <a href="http://en.wikipedia.org/wiki/Left_recursion">left-recursive grammars</a>, which is the most natural way to write certain types of grammars<sup><a id="return-leftrecursion" href="#note-leftrecursion">[2]</a></sup>. Typically, when writing a recursive descent parser, the author takes the grammar and produces a function for each production (non-terminal). Each function then reads a token and recurses to the other non-terminals in the grammar reachable from the current production. And, eventually, at the end of the function the sub parts will be combined in such a way that a <a href="http://en.wikipedia.org/wiki/Parse_tree">parse tree</a> will be created.</p>

<p>This sounds boring and tedious, and in fact is. However, there is a useful technique for creating these types of parsers that was developed some time ago<sup><a id="return-hutton1989" href="#note-hutton1989">[3]</a></sup>, which involves composing a small set of functions into more meaningful, more advanced parsers. They still suffer from the same problems as your typical recursive descent parser (as presented), but with some other trickery can be made to overcome those deficiencies (we won't discuss that in this article).</p>

<p>In order to build a parser from the ground up, we need to think about what a parser actually is. In some sense, it is really just a function that takes an input string and produces some result. That result, in order to make any progress should contain the leftover string after consuming some part of it, or in the case of error (i.e. incorrect input), return some value indicating failure. In Python, a natural way to encode both results would be to use <code class="inline">(<em>"matched string"</em>, <em>"leftover string"</em>)</code> or <code class="inline">None</code>. For sanity's sake, let us refer to functions which match this criteria as <em>parser functions</em>.</p>

<p>To start off, we'll write a useful parser function, which at first glance seems pointless, <code class="inline">anychar</code>. <code class="inline">anychar</code> matches <em>any</em> (no trickery here!) character so long as there is at least one character left in the input string. (<strong>Note:</strong> we'll use the variable <code class="inline">strn</code> to always refer to the input string, which represents the <em>string left to parse</em>.)</p>

<pre><code>def anychar(strn):
    if strn == "":
        return None
    return (strn[0], strn[1:])
</code></pre>

<p>It is easy to see that the result of this parser function matches our encoding. If there are no characters left in <code class="inline">strn</code>, then we return the failure condition, <code class="inline">None</code>, otherwise we return a tuple of what we parsed, and the rest of the string which we didn't parse.</p>

<p>It becomes more useful when we pair <code class="inline">anychar</code> with a test against the character it consumes. Enter <code class="inline">chartest</code>, which is a function that creates another parser function, given a predicate (i.e. a function which returns <code class="inline">True</code> or <code class="inline">False</code>).</p>

<pre><code>def chartest(pred):
    def _(strn):
        c = anychar(strn)
        if c and pred(c[0]):
            return (c[0], c[1])
        return None
    return _
</code></pre>

<p>In order to use <code class="inline">chartest</code>, we pass it a predicate, like so:</p>

<pre><code>&gt;&gt;&gt; chartest(lambda x: x == 'a')('abc')
('a', 'bc')
</code></pre>

<p>To see what happened, remember that <code class="inline">chartest</code> <em>creates</em> a new parser function. With that, we just call the new parser function with the rest of the input string <code class="inline">'abc'</code>. The result indicates success, because an <code class="inline">'a'</code> was discovered as the first character. If we were unsuccessful, just like in <code class="inline">anychar</code>, instead of <code class="inline">('a', 'bc')</code>, we'd have seen <code class="inline">None</code> returned.</p>

<p>It is a bit verbose to always create a <code class="inline">lambda</code> to match a single character, so <code class="inline">matchchr</code> gets a target character and calls <code class="inline">chartest</code> for us. (Remember, calling <code class="inline">chartest</code> creates a <em>new</em> parser function, this is an important thing to note.)</p>

<pre><code>def matchchr(targetchr):
    return chartest(lambda x: x == targetchr)
</code></pre>

<p>Now we can match single characters against our input stream, which is a great starting point, but hardly makes for an easy to use library. One limitation is that there is no way to specify more than one character as a possible match, such as "all alpha numeric"&mdash;for that, we use <code class="inline">oneof</code>.</p>

<pre><code>def oneof(target):
    chars = set([x for x in target])
    return chartest(lambda x: x in chars)
</code></pre>

<p><code class="inline">oneof</code> creates a new test function to pass to chartest, which instead of testing if a character is equal to a single target character, checks to see if the character is in the set of characters we're looking for. Some useful definitions follow, which make parser functions using <code class="inline">oneof</code>, and a set of characters.</p>

<pre><code>alpha = oneof('abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ')
loweralpha = oneof('abcdefghijklmnopqrstuvwxyz')
upperalpha = oneof('ABCDEFGHIJKLMNOPQRSTUVWXYZ')
digit = oneof('0123456789')
hexdigit = oneof('0123456789abcdefABCDEF')
whitespace = oneof(' \t\n\r')
</code></pre>

<p>While matching a single character is useful, it would be much more useful if we could match a <em>token</em>, like "<code class="inline">while</code>," or "Content-Type." Not to worry, <code class="inline">matchstr</code> produces a parser function that will combine the previously created <code class="inline">matchchr</code> for each character in the target string. It looks a bit complicated, so we'll go through it step by step.</p>

<pre><code>def matchstr(target):
    if not target:
        return lambda strn: ("", strn)

    def _(strn):
        c = matchchr(target[0])(strn)
        if c:
            cs = matchstr(target[1:])(c[1])
            if cs:
                return (c[0] + cs[0], cs[1])
        return None
    return _
</code></pre>

<p><code class="inline">target</code>, just like <code class="inline">targetchr</code> in <code class="inline">matchchr</code> is the string we're eventually trying to match in full. If <code class="inline">target</code> is empty, then our parser function is simple&mdash;it doesn't advance the input string, and doesn't consume anything.</p>

<p>Why don't we return <code class="inline">None</code> here? Well, if our target is empty, we're not asking <code class="inline">matchstr</code> to do any work at all, so there isn't a failure (indicated by <code class="inline">None</code>). It, however, also makes for a great base case to the recursion that follows.</p>

<p>If there <em>is</em> a target string to match against, we attempt to match the first character within it. If that succeeds, we shorten the target string and recurse. We eventually return a combination of the result of <code class="inline">matchchr</code> and the result of the recursive call to <code class="inline">matchstr</code>. Take a minute to look over this and ensure you understand it&mdash;it's actually pretty straightforward assuming understanding of the previous functions.</p>

<p>Let's take a look at how we use it:</p>

<pre><code>&gt;&gt;&gt; matchwhile = matchstr('while')
&gt;&gt;&gt; matchwhile('while True:')
('while', ' True:')
</code></pre>

<p>As you can see, we used <code class="inline">matchstr</code> to <em>build</em> a parser function which matches the string "<code class="inline">while</code>"&mdash;simple enough.</p>

<p>Ok, so what if we want to parse more complicated things, like say, the rest of the input string from the "while True:" example? We need some ways to combine these parser functions to make them more useful, otherwise, all we did was create the equivalent of:</p>

<pre><code>if strn.startswith("while"):
    return (strn[0:5], strn[5:])
</code></pre>

<p>Which, in Python, would be much more efficient!<sup><a id="return-efficiency" href="#note-efficiency">[4]</a></sup>

<p>Another parser function that we need to make this whole thing useful is <code class="inline">optional</code>. <code class="inline">optional</code> takes as an argument a parser function, and returns a new parser function that succeeds even if the original parser function does not. Essentially, if there is a failure, it returns the original input string.</p>

<pre><code>def optional(parserfn):
    def _(strn):
        c = parserfn(strn)
        if c:
            return c
        return ('', strn)
    return _
</code></pre>

<p>If we make <code class="inline">matchwhile</code>, from above, optional we get this:</p>

<pre><code>&gt;&gt;&gt; optional_matchwhile = optional(matchwhile)
&gt;&gt;&gt; optional_matchwhile('foo')
('', 'foo')
</code></pre>

<p>Without <code class="inline">optional</code>, attempting to call <code class="inline">matchwhile</code> on the input string <code class="inline">'foo'</code> would have resulted in <code class="inline">None</code>, the failure condition.</p>

<p>The presence of <code class="inline">optional</code> also leads us to <code class="inline">repeat</code> and <code class="inline">repeat0</code> which are mutually exclusive. <code class="inline">repeat</code> will attempt to match the parser function at least once, with no boundary. <code class="inline">repeat0</code> will match the parser function zero or more times:</p>

<pre><code>def repeat(parser):
    def _(strn):
        c = parser(strn)
        if c:
            cs = repeat0(parser)(c[1])
            return (c[0] + cs[0], cs[1])
        return None
    return _

def repeat0(parser):
    return optional(repeat(parser))
</pre></code>

<p>Again, like <code class="inline">optional</code>, <code class="inline">repeat</code> and <code class="inline">repeat0</code> build parser functions from existing ones. This is very much a common pattern when building parsers of this type.</p>

<p>The implementation of <code class="inline">repeat0</code> and <code class="inline">repeat</code> is quite clever. Note that zero or more is the same as <em>optionally</em> one or more. The implementation of both follows from that realization. <code class="inline">repeat</code> first attempts to call the passed in parser function. If it succeeds it calls <code class="inline">repeat0</code> on the rest of the input string after calling <code class="inline">parser</code> the first time. If <code class="inline">repeat0</code> succeeds, which it always will given <code class="inline">optional</code>, we combine the results and return.

<pre><code>&gt;&gt;&gt; optrepeat_while = repeat0(matchwhile)
&gt;&gt;&gt; optrepeat_while('whilewhilewhile')
('whilewhilewhile', '')
&gt;&gt;&gt; optrepeat_while('foo')
('', 'foo')
&gt;&gt;&gt; repeat_while = repeat(matchwhile)
&gt;&gt;&gt; repeat_while('foo')
None
&gt;&gt;&gt; repeat_while('while foo')
('while', ' foo')
</code></pre>

<p>We still need the ability to do alternation, like "while" <em>or</em> "if." For that we introduce <code class="inline">alt</code>.</p>

<pre><code>def alt(*parsers):
   def _(strn):
       for p in parsers:
           result = p(strn)
           if result:
               return result
   return _
</code></pre>

<p>This is really simple. We take a list of parser functions and try them one by one, from left to right, until we find one that passes.</p>

<pre><code>&gt;&gt;&gt; iforwhileorfor = alt(matchstr('if'), matchstr('while'), matchstr('for'))
&gt;&gt;&gt; if_while_for('if')
('if', '')
&gt;&gt;&gt; if_while_for('while')
('while', '')
&gt;&gt;&gt; if_while_for('for')
('for', '')
&gt;&gt;&gt; if_while_for('foof')
None
</code></pre>

<p>Alternation is important, but it is maybe even <em>more</em> important to ensure that many parser functions pass in order, a sequence of parser functions if you will. It is this operator that allows us to do something like <code class="inline">whilestmt = sequence(whileToken, conditional, colonToken, codeBlock)</code>.</p>

<pre><code>def sequence(*parsers):
    def _(strn):
        parsed = ''
        rest = strn
        for p in parsers:
            result = p(rest)
            if result:
                rest = result[1]
                parsed += result[0]
            else:
                return None
        return (parsed, rest)
    return _
</code></pre>

<p>Assuming simplified definitions of the supporting rules, our <code class="inline">whileStmt</code> example looks something like this:</p>

<pre><code>&gt;&gt;&gt; whileToken = matchstr("while")
&gt;&gt;&gt; conditional = oneof("&gt;&lt;=")
&gt;&gt;&gt; colonToken = matchchr(":")
&gt;&gt;&gt; codeBlock = alt(matchstr("if"), matchstr("for"))
&gt;&gt;&gt; whileStmt = all(whileToken, conditional, colonToken, codeBlock)
&gt;&gt;&gt; whileStmt('while&lt;:if')
('while&lt;:if', '')
&gt;&gt;&gt; whileStmt('while&gt;:if')
('while&gt;:if', '')
&gt;&gt;&gt; whileStmt('while>:for')
('while&gt;:for', '')
&gt;&gt;&gt; whileStmt('while:for')
None
</code></pre>

<p><code class="inline">sequence</code> looks complicated, but is rather simple. It is basically <code class="inline">reduce</code>, combining the results of each parser into the results of all of the parser function outputs together.</p>

<p>That's all we really need to construct more interesting parsers, so we'll now construct a simplified parser for JSON.<sup><a id="return-json" href="#note-json">[5]</a></sup></p>

<p>We'll start with some utility functions:</p>

<pre><code>def betweenchrs(parser, left="(", right=")"):
    def _(strn):
        lres = matchchr(left)(strn)
        if lres:
            pres = parser(lres[1])
            if pres:
                rres = matchchr(right)(pres[1])
                if rres:
                    return (left + pres[0] + right, rres[1])
        return None
    return _

betweenparens = lambda p: betweenchrs(p, left="(", right=")")
betweenbrackets = lambda p: betweenchrs(p, left="[", right="]")
betweencurlies = lambda p: betweenchrs(p, left="{", right="}")
</code></pre>

<p><code class="inline">betweenchrs</code> lets us easily create a parser function which attempts to parse, using <code class="inline">parser</code>, only if it is between <code class="inline">left</code> and <code class="inline">right</code>. This is useful in JSON, because of its list and dictionary data types, which are delimited by <code class="inline">[]</code> and <code class="inline">{}</code> respectively.</p>

<p>Strings in JSON are composed of a series of characters between <code class="inline">"</code>'s. But, if you want to actually use a <code class="inline">"</code> within the string, you can do that by preceding it with a <code class="inline">\</code>. We can make a parser function that satisfies these rules rather easily, making use of <code class="inline">anychar</code>.</p>

<pre><code>def charorquoted(strn):
    c = anychar(strn)
    if c[0] == '"':
        return None
    elif c[0] == '\\':
        c2 = chartest(lambda x: x in ('\\', '"'))(c[1])
        if c2:
            return (c[0] + c2[0], c2[1])
    else:
        return c
</code></pre>

<p>In the case that we find a '"' character without a '\' character preceding it, it is a failure.</p>

<p>Whitespace doesn't much matter between tokens in JSON, so let us define something that ultimately ignores it. <code class="inline">ignorews</code> uses <code class="inline">repeat0</code> to strip the preceding whitespace, calls the parser function given using the left over input string. If the parser function passes, it calls <code class="inline">repeat0</code> again against whitespace and ultimately returns the passed in parser function's parsed result and the ignored whitespace's left over input string. That's a mouthful, but it's fairly easy to understand:</p>

<pre><code>def ignorews(p):
    def _(strn):
        w = repeat0(whitespace)(strn)
        if w:
            pres = p(w[1])
            if pres:
                w2 = repeat0(whitespace)(pres[1])
                if w2:
                    return (pres[0], w2[1])
        return None
    return _
</code></pre>

<p><code class="inline">anint</code>, <code class="inline">astring</code>, <code class="inline">acolon</code> and <code class="inline">acomma</code> are just helper functions which do exactly what they describe. We're simplifying this implementation, as it is for demonstration purposes, so we're not taking into consideration floating point numbers, or integers specified using hexidecimal and other formulations of numbers.</p>

<pre><code>anint = sequence(optional(matchchr("-")), repeat(digit))
astring = betweenchrs(repeat0(charorquoted), left='"', right='"')
acolon = matchchr(':')
acomma = matchchr(',')
</code></pre>

<p>When we define dictionaries and lists, we run into a problem. Both lists and dictionaries can contain lists and dictionaries (as well as numbers and strings of course), which represents a problem for when we define these functions (we can't recursively define something that doesn't already exist!). One solution to this problem is to use a mutable object which acts as a "forward reference." When we finish defining the pieces we need, we update the forward reference, and then all is well.</p>

<p>For both aesthetic, and practical reasons, we'll use a class instance which overrides <code class="inline">__call__</code>, and  <code class="inline">__ilshift__</code>, which will allow us to use an instance of <code class="inline">Forward</code> as a parser function, and <code class="inline">&lt;&lt;=</code> (from __ilshift__) as a way to update the parser function that's contained within the reference.</p>

<pre><code>class Forward(object):
    def __init__(self):
        self.p = None

    def __call__(self, *args, **kwargs):
        return self.p(*args, **kwargs)

    def __ilshift__(self, p):
        self.p = p
        return self
</code></pre>

<p>To use a <code class="inline">Forward</code>, we simply create an instance of <code class="inline">Forward</code> and assign it to a variable, just as if we were creating a parser function. <code class="inline">Forward</code> is like a promise. "If you act like a parser function for me for a little bit, I promise I'll actually turn you into one later." If the promise is kept, and the <code class="inline">Forward</code> is updated, parsing will proceed as if nothing was ever not specified to begin with.</p>

<pre><code>avalue = Forward()
akey = ignorews(alt(anint, astring))
akeyvaluepair = sequence(akey, acolon, avalue)
</code></pre>

<p>Both lists and dictionaries have items that are separated by comma. <code class="inline">commaseparated</code> is essentially <code class="inline">repeat0</code> except that it ensures a comma appears after each item, except in the last item.

<pre><code>def commaseparated(parser):
    def _(strn):
        r = repeat0(sequence(parser, acomma))(strn)
        if r:
            r2 = parser(r[1])
            if r2:
                return (r[0] + r2[0], r2[1])
        elif r:
            return r
        return None
    return _
</code></pre>

<p>Now that we have all the pieces specified, we put a <code class="inline">commaseparated</code> key value pair between curly braces to parse a dictionary, and a <code class="inline">commaseparated</code> value parser function between square brackets to parse a list.</p>

<pre><code>adict = betweencurlies(commaseparated(akeyvaluepair))
alist = betweenbrackets(commaseparated(avalue))
</code></pre>

<p>We still have our promise to keep for <code class="inline">avalue</code>, and with the definitions of <code class="inline">alist</code> and <code class="inline">adict</code>, we now can. <code class="inline">avalue</code>, as in JSON, should either be a number, a string, a list or a dictionary, and whitespace is ignored.</p>

<pre><code>avalue <<= alt(*map(ignorews, [adict, alist, anint, astring]))
</code></pre>

<p>To achieve alternation, we make use of <code class="inline">alt</code>, but before we do that, we wrap each parser function contained in <code class="inline">avalue</code> in an <code class="inline">ignorews</code> parser function builder to satisify that requirement. Finally, we shift the newly created parser function into the forward reference for <code class="inline">avalue</code>.</p>

<p>To parse a top level JSON document, we look for either a list, or a dictionary. The parser function to do that is quite easy to specify.</p>

<pre><code>json = alt(adict, alist)
</code></pre>

<p>Last, but certainly not least, let's actually use what we've constructed:</p>

<pre><code>&gt;&gt;&gt; json('''{"hello": {1: "how are you?"}, "i is": "fine", "how": "are you?", 1: ["these", "values", "work", 2]}''')
('{"hello":{1:"how are you?"},"i is":"fine","how":"are you?",1:["these","values","work",2]}', '')
</code></pre>

<p>Success!</p>

<p>While we haven't shown how to formulate an LL(k) grammar, or even talked about what that actually is formally, we have shown that with a few simple functions that build parser functions, we can build, quite easily, parsing functions which parse complicated things. However, we've only shown that the input is valid, actually constructing a parse tree, or acting upon it, is left as an exercise to the reader.</p>

<p>Source code for all this is <a href="http://files.sigusr2.net/parser_functions.py">here</a>

<ol class="footnotes">
   <li id="note-solvedproblem">I'm not sure if parsing is really "solved," but the algorithms we have work well enough in practice that there isn't a ton of interesting new research going on around it. <a href="http://arxiv.org/abs/1010.5023">Yacc is Dead</a>, for instance used the results of <a href="http://portal.acm.org/citation.cfm?id=321249">a paper</a> from 1964, but came <a href="http://research.swtch.com/2010/12/yacc-is-not-dead.html">under fire</a>. Can parsing be made trivially easy? Maybe, but it's likely that ambiguity will be somewhere&mdash;which would be the unsolved in parsing.<a href="#return-solvedproblem">&crarr;</a></li>
   <li id="note-leftrecursion">See <a href="#note-leftrecursion">left</a> <a href="http://en.wikipedia.org/wiki/Left_recursion">recursion</a>. All joking aside, left recursion occurs in a grammar when a non-terminal rule is used recursively and appears on the left. For example: <code class="inline">expr = expr + tail</code>. <a href="#return-leftrecursion">&crarr;</a></li>
   <li id="note-hutton1989">Graham Hutton. Proceedings of the 1989 Glasgow Workshop on Functional Programming (Fraserburgh, Scotland), Springer-Verlag Series of Workshops in Computing, Springer-Verlag, Berlin, 1990.<a href="#return-hutton1989">&crarr;</a></li>
   <li id="note-efficiency">The purpose of this article isn't to describe an efficient parsing technique for Python, but to rather demonstrate a useful technique that could be adapted and built upon, to build an efficient parsing framework for <em>any</em> language that supports first class functions. There's a follow up article to this which shows just how much of this can actually be abstracted out in order to make it even more simple.<a href="#return-efficiency">&crarr;</a></li>
   <li id="note-json">We limit our parser to strings, integers, dictionary and lists. The complete specification appears at <a href="http://json.org">http://json.org</a><a href="#return-json">&crarr;</a></li>
</ol>
]]></content></entry>
<entry><title>Softserv Serves Requests</title><link href="http://sigusr2.net/2011/Jan/07/softserve-serves-requests.html"/><id>md5:093bb5e2a8d89cf283efb8984e24d0ab</id><updated>2011-01-07T00:00:00Z</updated><content type="html"><![CDATA[<p>
   <span class="preamble">Anyone that knows me knows that I have a lot of projects, most of which are in some sort of unfinished but partially functional state. Then there are others that have a solid 0.1 release, maybe lacking documentation, but usable. There are yet others that never make it to 0.1, and despite my happy thoughts about how this piece of code will change the world, or be the future, it's as good as deadpooled.</span>
</p>

<p>
One project that will certainly not be deadpooled is being developed in my 10% time at work, though on hiatus whilst I resolve some other issues that I inadvertently committed and finish up some other tasks that have higher priority.
</p>

<p>But, I don't wanna discuss that project right now, it is in a sort of discovery phase where I'm attempting to iron out the network protocol, and what functionality it actually provides for its initial run<sup><a href="#note-nonblocking">[1]</a></sup>.</p>

<p>It does, however, do what many servers do&mdash;listen to and accept requests via a socket.</p>

<p>Clojure comes with many ways, of course, to do just that. It is certainly possible to use one of the many frameworks for Java for writing servers, but clojure.contrib/server-socket, looked to be exactly what I needed, and I decided to have a look.</p>

<p>When evaluating any sort of library, the first thing I always do is create something simple that makes use of it. This is not uncommon of course, and the "Hello World" of network programming is the trusted echo server, in which, everything you say will be parroted back to you. That's pretty simple using server-socket:</p>

<pre><code class="clojure">(ns echo
  (:require [clojure.contrib.server-socket :as ss]
            [clojure.contrib.duck-streams :as ds]))

(defn echo-server [in out]
  (binding [*in* (ds/reader in)] <a href="#note-with-in-reader"><sup>[2]</sup></a>
     (ds/with-out-writer out
        (println (read-line)))))

(ss/create-server 1025 echo-server)

(comment
$ echo "HELLO WORLD" | nc 127.0.0.1 1025
HELLO WORLD
$ 
)</code></pre>

<p>Simple enough, but it is unfortunately <em>too</em> simple. For one, it creates a thread per connection, which is just asking for trouble with a public server. Secondly, since it only gives you an <code class="inline">InputStream</code> (<code class="inline">in</code>) and an <code class="inline">OutputStream</code> (<code class="inline">out</code>), there isn't a way to log who connected, or anything about the user who connected other than time. Hell, there's nothing guaranteeing that you're even connecting via a network for this!</p>

<p>Now, I understand that <code class="inline">server-socket</code> was not really meant for production use&mdash;it is meant for quick toying around, and testing out ideas as quickly as possible, something it does extremely well, but with a little bit of modification, I think it can be almost just as simple and still be suitable for production use.

<p>Enter <a href="http://github.com/apgwoz/softserv">softserv</a>, a still simple, but slightly more complicated replacement for server-socket.</p>

<p>So what is more complicated about it? Let's look at "Hello World" and find out:</p>

<pre><code class="clojure">(ns echo
  (:use [softserv.core :only (create-server
                              defservice
                              defhandler
                              with-shutdown)])
  (:require [clojure.contrib.duck-streams :as ds]))

(defn echo-parser [s]
  (binding [*in* (ds/reader s)]
    {:data (read-line) :type :echo}))

(defservice echo-server :type echo-parser)

(defhandler echo-server :echo
  [s req]
  (with-shutdown s
    (ds/with-out-writer s
      (println (:data req)))))

(create-server 1025 echo-server 10)

(comment
$ echo "HELLO WORLD" | nc 127.0.0.1 1025
HELLO WORLD
)</code></pre>

<p>Phew! That was a mess of code to write to get a simple echo server, surely softserv isn't so, well, soft? Just look at what we've gained, though!</p>

<p>First and foremost, we've gained the ability to specify a maximum number of threads to create. That's what the <code class="inline">10</code> is for in <code class="inline">create-server</code>. Softserv executes request handlers in a thread pool. This of course has some limitations over the thread-per-connection model (like making it harder to allow for long running session based servers), but for resource constrained single request services, it's probably a plus. Maybe relaxing this requirement and figuring out an appropriate way to handle long running connections is a good next step.</p>

<p>Secondly, and without any hit in the number of symbols or parentheses, we're passing an actual socket object to the function that does the handling. You'd think that we'd have to call <code class="inline">(.getInputStream s)</code>, but <code class="inline">duck-streams</code> knows how to get an <code class="inline">InputStream</code> for a <code class="inline">Socket</code>. This is almost identical to the original example.</p>

<p>Third, and most importantly, we've made it possible to dispatch based on the type of request. Softserv enforces what you'd have done anyway. The handler function that <code class="inline">server-socket/create-server</code> takes in almost all cases will end up being a <code class="inline">cond</code> statement dispatching to other functions. Softserv just makes that explicit and up front.</p>

<p>Enough chatter, how can I make use of it? Well, our echo server would be much more interesting if in fact we echoed back more interesting things. For instance, we could translate the input, or rot-13 the input, or for ease of illustrative purposes echo back the actual date, a more useful echo, when someone sends the string "DATE".</p>

<pre><code class="clojure">(ns echo
   (:use [softserv.core :only (create-server
                               defservice
                               defhandler
                               with-shutdown)])
<span style="color: red;">-  (:require [clojure.contrib.duck-streams :as ds]))</span>
<span style="color: green;">+  (:require [clojure.contrib.duck-streams :as ds])</span>
<span style="color: green;">+  (:import [java.util Date]))</span>

(defn echo-parser [s]
  (binding [*in* (ds/reader s)]
<span style="color: red;">-    {:data (read-line) :type :echo}))</span>
<span style="color: green;">+    (let [l (read-line)]</span>
<span style="color: green;">+      (assoc {:data l} :type (if (= l "DATE") :date :echo)))))</span>

(defservice echo-server :type echo-parser)

<span style="color: green;">+(defhandler echo-server :date</span>
<span style="color: green;">+  [s req]</span>
<span style="color: green;">+  (with-shutdown s</span>
<span style="color: green;">+    (ds/with-out-writer s</span>
<span style="color: green;">+      (println (str (Date.))))))</span>

(create-server 1025 echo-server 10)

(comment
$ echo "HELLO WORLD" | nc 127.0.0.1 1025
HELLO WORLD
$ echo "DATE" | nc 127.0.0.1 1025
Wed Jan 05 08:29:38 EST 2011
)
</code></pre>

<p>Using a single request parsing function of course has its limitations, but in general, network services are not the type of thing that really have diverse request types. The protocol normally allows you to tell within a few bytes what kind of request it is. In the case of softserv servers the handlers can then finish reading the request and taking the appropriate actions.</p>

<p>I'd really appreciate any feedback on this.</p>

<ol class="footnotes">
    <li id="note-nonblocking">There's also the question of non-blocking vs. blocking, but the first pass will be blocking until there are real numbers to look at.</li>
    <li id="note-with-in-reader">I'm not sure of the reasoning, but <code class="inline">(with-in-reader s ...)</code> throws an exception saying java.io.PushbackReader cannot be cast to java.io.BufferedReader. This doesn't seem right to me, since it'd work if it were a LineNumberingPushbackReader, but PushbackReader's don't have a <code class="inline">.readLine</code> method, and don't derive from BufferedReader. Nevertheless, I feel as though read-line should know how to handle it, or wrap the PushbackReader in a LineNumberingPushbackReader temporarily, if that's possible.</li>
</ol>
]]></content></entry>
<entry><title>unipoint-mode: A minor-mode for Mathematical Unicode</title><link href="http://sigusr2.net/2010/Nov/04/unipoint-minor-mode-for-mathematical-unicode.html"/><id>md5:51002542f1e8ffaff3c09d17aea84c99</id><updated>2010-11-04T00:00:00Z</updated><content type="html"><![CDATA[<p><span class="preamble">Last week I <a href="http://fold.sigusr2.net/2010/10/sir-please-step-away-from-the-asr-33-acm-queue.html">reblogged</a> Poul-Henning Kamp's article <a href="http://queue.acm.org/detail.cfm?id=1871406">"Sir, Please Step away from the ASR-33"</a>.</span></p>

<p>If you haven't read it, do so. It has an interesting outlook on what it means to write code, and asks the question, "why the hell are we stuck in the 60s?" His basic premise is that we're married to ASCII, despite having all sorts of other characters at our disposal via unicode, which provides much clearer and concise possibilities for syntax. He also goes on about how none of us have monochromatic screens, so color could play some role in what our programs mean, as well as arguing that the vertical nature of code is unjustified, since we have column editing.</p>

<p>If you ask me, his other arguments are crap, but the unicode argument is completely valid. There's just one problem, have you ever tried to type unicode? It's a mess. In Emacs, to type &rarr;, it's <code class="inline">C-x 8 RET RIGHTWARDS ARROW RET</code>, or if you know the hex value, <code class="inline">C-x 8 RET 2192 RET</code>. Sure, there are <a href="http://xahlee.org/emacs/emacs_n_unicode.html">other options</a>, but most editors aren't nearly as flexible to customize as Emacs is, so who knows what it's like outside of it&mdash;I can't imagine it's any better.</p>

<p>But, when I commented on the fact that "typing unicode sucks," I was greeted by an email from a friend of mine:</p>

<blockquote><a href="http://racket-lang.org/">DrRacket</a> lets you enter common Unicode characters by typing their
LaTeX name followed by control-\. For example, you type &isin; by typing
"\", "i", "n", "control-\". It's easy enough that I use Unicode in my
code all the time.

I bet it wouldn't be too hard to hack something like this feature into Emacs.<span class="closequote"></span>
<cite>&mdash;<a href="http://users.eecs.northwestern.edu/~clk800/">Casey Klein</a></cite>
</blockquote>

<p>This got me thinking about the problem, and in 20 minutes I had <code class="inline">C-\</code> bound to a function that would read a TeX symbol name from the minibuffer and looked up the unicode character in a table then spit it out. I then began to go on a typing spree, seeing how easy it actually was to use. Of course, this wasn't exactly what Casey had described, but it was close enough, and made it way better than before.</p>

<p>It actually had some great features of it's own, too. For one, it had TAB completion, to cut down on typing. DrRacket didn't have that.</p>

<p>I told Casey about my efforts and mentioned TAB completion and how "this isn't all that bad." Casey was intrigued by the TAB completion, and I wanted to see if <code class="inline">C-\</code> after typing \in was better&mdash;it is, but there's still value some value in the prefixed entry.</p>

<p>So now I had a function bound that would do the right thing. If point was at the end of a word boundary with a \ to the left of it (the word), it'd attempt to convert the sequence to a symbol, otherwise it'd be left alone. If you were in empty space or the completion failed, you'd be asked for the symbol as if you were going the prefix route.</p>

<p>This all worked wonderfully well, and our conversation about why I don't like entering unicode went on; he was still convinced it was woefully easy. I, too, was beginning to see that it's not as painful with the proper tools as I originally thought.</p>

<p>The 43 message thread of back and forth sparked inspiration in him around the idea of completion for DrRacket. His idea was simple, hit <code class="inline">C-\</code> and it'd attempt to complete whatever was before it, or output the longest subsequence of the symbols, prefixed with whatever you typed, in the lookup table. In other words, if you had "\sub" it'd complete to "\subset" because both "\subset" and "\subseteq" are in the lookup table. Hit <code class="inline">C-\</code> again and the substitution to &isin; takes place.</p>

<p>I couldn't help but be inspired to add that behavior to what I had now dubbed <a href="http://github.com/apgwoz/unipoint">unipoint</a>. His <a href="https://github.com/plt/racket/commit/bd0ebc7511c7b66dfdd0b24d68dbe27077a9a7dd">changes</a> went into DrRacket</a>. We both found solace in the fact that typing symbols was a bit easier than it was before.</p>

<p>I'm a lot less scared now to see symbols in code, and certainly advocating for them, so long as they stay mathematical in nature. I can't help but feel, though, that most people see this still as a problem. It's because of this that I recorded a quick screencast tutorial (no audio) of how unipoint is used. Hopefully it does its job in showing that it doesn't have to be so painful, and Kamp's dream will eventually become a reality.</p>

<iframe src="http://player.vimeo.com/video/16461894" width="400" height="300" frameborder="0"></iframe>
]]></content></entry>
<entry><title>ant.el: A Code Walkthrough</title><link href="http://sigusr2.net/2010/Oct/29/ant-el-a-code-walkthrough.html"/><id>md5:190c53e1eb58b5488ccc339134ad7766</id><updated>2010-10-29T00:00:00Z</updated><content type="html"><![CDATA[<p><span class="preamble">In April of last year, I blogged about <a href="http://sigusr2.net/2009/Apr/30/the-power-that-is-gnu-emacs.html">how powerful Emacs</a> is, and shared my enlightenment story.</span></p>

<p>Today, I'm even closer to Emacs than I was before, having an extra year and a half of experience than I did then. My daily interactions with Emacs are still very much in the same vain&mdash;I am still a programmer after all, but I've also discovered some more frustrations which were fairly easy to rectify.</p>

<p>In July of this year, I started <a href="http://www.meetup.com/">a new job</a><sup><a href="#hiring-1">[1]</a></sup>. My role at Meetup has been different in many regards than my previous jobs. It's the first role I've had since entering into the industry that someone doesn't see the output of my code. In fact, if they do see the output of my code, I've sort of failed.<sup><a href="#output-2">[2]</a></sup> It also represents the first time that I've primarily used a compiled language (outside of college), targetted the <a href="http://en.wikipedia.org/wiki/JVM">JVM</a> and used <a href="http://java.sun.com/">Java</a> for the bulk of my work.</p>

<p>Naturally, Emacs could help me. <a href="http://www.gnu.org/software/emacs/manual/html_node/emacs/Compilation-Mode.html">Compilation Mode</a>, for instance allows you to do <code class="inline">M-x compile</code> to run <a href="http://en.wikipedia.org/wiki/Make_(software)">make</a>, or <a href="http://ant.apache.org/">ant</a> (with <code class="inline">-emacs</code>) or some other build tool that generates compilation mode compatible output, that the mode will then mark up and allow you to easily jump to places the compiler thinks<sup><a href="#errors-3">[3]</a></sup> are errors.</p>

<p>Compilation Mode by default is fine, but complicated Java source trees are normally nested quite complexly and ant isn't the greatest at locating a suitable build file. What I needed were some interactive functions that I could use to run ant properly, in Compilation Mode using the project's build file. What I <a href="http://github.com/apgwoz/ant-el">came up with</a> after a few hours, works fairly well.</p>

<p>Basically, instead of <code class="inline">M-x compile</code>, I type <code class="inline">M-x ant</code>, or <code class="inline">M-x ant-compile</code>, or <code class="inline">M-x ant</code> and then TAB complete all the available build targets. This allows me to save some typing, and save some precious brain cells, since I don't have to remember all 40 build targets.</p>

<p>The code is fairly simple, and I think it's a great candidate for a walk through on how to solve your own problems using Emacs Lisp, so I'd like to go through it here.</p>

<p>The code starts out simply enough:</p>

<pre><code class="elisp">(defvar ant-last-task "compile")
(defvar ant-build-file-name "build.xml")
(defvar ant-command "ant -emacs")
(defvar *ant-tasks-cache* '())
(defvar *ant-tasks-command* "grep -e '&lt;target.*name=\"[^\-][^\"]*.*$'")
(defvar ant-tasks-default '("compile" "test" "clean"))</code></pre>

<p>We just define a bunch of global variables that can be overridden by a user if they need to be. We do however create <code class="inline">*ant-tasks-cache*</code> and <code class="inline">*ant-tasks-command*</code> which are meant to be internal state. In elisp, and other Lisps, wrapping * around a variable normally indicates that the variable is special in someway, here it means it's a global and shouldn't be modified outside of the functions defined within.</p>

<p>Next we have a helper function, <code class="inline">ant-find-tasks</code>, which, given a directory, issues a shell command <code class="inline">*ant-tasks-command*</code> that is used to extract the lines from the ant build file that declare targets:</p>

<pre><code class="elisp">(defun ant-find-tasks (directory)
  (let ((output (shell-command-to-string (concat *ant-tasks-command* " "
                                                 directory "/"
                                                 ant-build-file-name))))
    (if (> (length output) 0)
        (mapcar '(lambda (x) (replace-regexp-in-string ".*&lt;target.*name=\"\\([^\-][^\"]*\\).*" "\\1" x)) 
                (split-string output "[\n]"))
      nil)))</code></pre>

<p>Essentially, we first save the output of the shell command that gets built up to the variable <code class="inline">output</code>. If the length of <code class="inline">output</code> is greater than 0, we split the output (<code class="inline">split-string</code>) into individual lines, and iteratively replace the junk in the line with just the name of the target (<code class="inline">replace-regexp-in-string</code>). The only non-obvious thing in here is <code class="inline">mapcar</code> which is a fancy way of transforming a list into another list via the function passed as the first argument.</p>

<p>That gives us all the tasks defined in the build file&mdash;well for most cases anyway. It doesn't handle all possible, valid build.xml files, but should work if the <code class="inline">target</code>'s declaration and name attribute appear on the same line.</p>

<p>When we need a list of tasks for a project, we call <code class="inline">ant-tasks</code>. This function really just caches the returned value of <code class="inline">ant-find-tasks</code> into the global variable <code class="inline">*ant-tasks-cache*</code> for the current project:</p>

<pre><code class="elisp">(defun ant-tasks (directory)
  (let ((tasks (assoc-string directory *ant-tasks-cache*)))
    (or tasks
        (progn 
          (let ((newtasks (or (ant-find-tasks directory) ant-tasks-default)))
            (setq *ant-tasks-cache*
                  (cons (cons directory newtasks) *ant-tasks-cache*))
          newtasks)))))</code></pre>

<p>The only interesting thing about the above code is the use of <code class="inline">or</code>. In Lisp, <code class="inline">or</code> short circuits and returns the first truthy value&mdash;it doesn't convert it to a boolean, so it can easily be used to select the first truthy value from a list of values. That's what's happening there.</p>

<p>I mentioned that I wanted TAB completion on task names so as to not clutter my brain matter with useless task names:</p>

<pre><code class="elisp">(defun ant-get-task (directory)
  (let ((task (completing-read-multiple (concat "Task (default): ") 
                                        (ant-tasks directory))))
    (if (> (length task) 0)
        (mapconcat 'identity task " ")
      "")))</code></pre>

<p>Well, here it is. Emacs has built in completion via the <code class="inline">completing-read</code> function. Here, we want the ability to issue one or more tasks, so we use <code class="inline">completing-read-multiple</code> to get the job done. Notice we're calling our function from above, <code class="inline">ant-tasks</code>.</p>

<p>You'll notice <code class="inline">mapconcat</code> above. It's like <code class="inline">mapcar</code> from above, in that it takes a list of things and transforms them, but instead of returning a new list, it concatenates the elements into a string using the last argument (here just a space) as a separator. <code class="inline">completing-read-multiple</code> returns to us a list, which we need to turn into a string with spaces between the targets in order to issue the build command.</p>

<pre><code class="elisp">(defun ant-find-root (indicator)
  (let ((cwd default-directory))
    (while (and (not (file-exists-p (concat cwd indicator)))
                (not (string-equal (expand-file-name cwd) "/")))
      (setq cwd (concat cwd "../")))
    (if (file-exists-p (concat cwd indicator))
        (expand-file-name cwd)
      nil)))</code></pre>

<p>The above function locates the base directory of the project, given the current file being edited. It just loops up the file system looking for the first directory it finds that has a build file in it. When I originally wrote this function, I didn't realize that Emacs already had this functionality built into it with the function <code class="inline">locate-dominating-file</code>.<sup><a href="#dominating-4">[4]</a></sup>

<p><code class="inline">ant-kill-cache</code>,</p>

<pre><code class="elisp">(defun ant-kill-cache ()
  (interactive)
  (setq *ant-tasks-cache* '()))</code></pre>

<p>does exactly what it says it does. It destroys the cache that is built up from <code class="inline">ant-tasks</code>.

<p>The main entry point, <code class="inline">ant</code>, is fairly trivial as well. It sets the variable <code class="inline">default-directory</code>, which is Emacs' current working directory, to the project directory, reads a task from the reader (if being called interactively) and calls <code class="inline">compile</code>, which is the main entry point into Compilation Mode.</p>

<pre><code class="elisp">(defun ant (&optional task)
  "Run ant `task` in project root directory."
  (interactive)
  (let ((default-directory (ant-find-root ant-build-file-name)))
    (if default-directory
        (let ((task (or task (ant-get-task default-directory))))
          (setq ant-last-task task)
          (compile (concat ant-command " " task)))
      (message "Couldn't find an ant project."))))</code></pre>

<p>In the first code block, there was a variable, <code class="inline">ant-last-task</code>, defined that is used above to store the last target run. After a target is given, it's saved off in there.</p>

<pre><code class="elisp">(defun ant-last ()
  "Run the last ant task in project"
  (interactive)
  (ant (or ant-last-task "")))

(defun ant-compile ()
  (interactive)
  (ant "compile"))

(defun ant-clean ()
  (interactive)
  (ant "clean"))

(defun ant-test ()
  (interactive)
  (ant "test"))</pre></code>

<p>The rest of the code above, just defines some convenient, interactive commands for common targets. <code class="inline">M-x ant-compile</code> will just issue the compile target, likewise for <code class="inline">ant-clean</code>. The only moderately interesting interactive command here is <code class="inline">ant-last</code> which reuses the variable <code class="inline">ant-last-task</code> from above to redo the last compilation.</p>

<p>It doesn't feel like much code, and in all reality it's not. However, it has saved me quite a bit of time, as I don't have to go running to a terminal (either switching buffers, or switching windows entirely) in order to issue an ant task. I just do something I've grown very accustomed to&mdash;I issue another Emacs command, and let Emacs take care of it for me.</p>

<ol class="footnotes">
    <li id="hiring-1">We're hiring for <a href="http://www.meetup.com/jobs">most positions</a>.</li>
    <li id="output-2">Most of what I do is related to our product's infrastructure&mdash;not interaction, and not engineering new features. My work would be visible if some error leaked to your browser, and that'd probably be bad.</li> 
    <li id="errors-3">It's fairly difficult to trick the compiler, but in Java, for instance, you can write type-safe code using Generics that it can't prove is safe. If you do that though, you should make use the SuppressWarnings annotation to tell the compiler it's OK.</li>
    <li id="dominating-4">Actually, I wasn't surprised that Emacs actually had the functionality, just that the name is non-trivial. I gave up looking for it after a couple of minutes and just rolled my own. I'll replace it in a future version, but the existing code works for now.</li>
</ol>
]]></content></entry>
<entry><title>Clojure Conj Reading List</title><link href="http://sigusr2.net/2010/Oct/24/clojure-conj-reading-list.html"/><id>md5:bf830f7059334bc6e2722078fa36fb07</id><updated>2010-10-24T00:00:00Z</updated><content type="html"><![CDATA[<p>
   <span class="preamble">This past weekend, the first (hopefully annual) <a href="http://first.clojure-conj.org">Clojure Conj</a> took place in Durham, NC.</span></p>
<p>In my opinion, the conference was a great success, and was greatly inspirational, as well as enjoyable in many regards. I left the conference recharged with energy to better learn about and help improve the Clojure ecosystem, and just get more involved. But, that's not all I left with of course. I left with great information and even more pointers to new thoughts, opinions and ideas.</p>

<p>I've compiled a small reading list of things that were mentioned in talks. I also got a chance to (briefly) meet <a href="http://fogus.me">Michael Fogus</a>, whose talk discussed the influences of Clojure and asked him if it would be possible for him to make a reading list. I certainly hope he does. Anyway, here's my list:</p>
<dl>
   <dt>
      <q><a href="http://www.gdmc.nl/publications/2008/MonetDB.pdf">MonetDB, a novel spatial column-store DBMS</a></q>&mdash;Maarten Vermeij, Wilko Quak, Martin Kersten, Niels Nes
   </dt>
   <dd>
      <em>Abstract</em>: Column-store database engines are a promising track in database research to handle data warehouses. In this paper we describe our experiences in extending the open-source database management system MonetDB with geo-spatial functionality. The approach taken is to leverage the existing geo-spatial software library GEOS through the extensibility features of this DBMS. The result is a high-performance solution using a software stack that enables future research and development improvements in many directions. In our paper we first give an overview of the MonetDB architecture then we describe how this architecture is beneficial for the handling of spatial data.
   </dd>
   <dt>
      <q><a href="http://www.st.cs.uni-saarland.de/edu/seminare/2005/advanced-fp/docs/huet-zipper.pdf">The Zipper</a></q>&mdash;Gerard Huet
   </dt>
   <dd>
      <em>Capsule Review</em>: Almost every programmer has faced the problem of representing a tree together with a subtree that is the focus of attention, where that focus may move left, right, up or down the tree. The Zipper is Huet's nifty name for a nifty data structure which fulfills this need. I wish I had known of it when I faced this task, because the solution I came up with was not quite so efficient or elegant as the Zipper.
   </dd>
   <dt>
      <q><a href="http://www.amazon.com/gp/product/0465024114?ie=UTF8&amp;tag=siusdesi2-20&amp;linkCode=as2&amp;camp=1789&amp;creative=390957&amp;creativeASIN=0465024114">Finding Flow: The Psychology of Engagement with Everyday Life</a></q>&mdash;Mihaly Csikszentmihalyi
   </dt>
   <dt>
      <q><a href="http://www.amazon.com/gp/product/0716704633?ie=UTF8&amp;tag=siusdesi2-20&amp;linkCode=as2&amp;camp=1789&amp;creative=390957&amp;creativeASIN=0716704633">Computer Power and Human Reason</a>&mdash;Joseph Weizenbaum</q>
   </dt>
   <dt>
      <q><a href="http://www.soi.city.ac.uk/~ross/papers/FingerTree.pdf">Finger Trees: A Simple General-purpose Data Structure</a></q>&mdash;Ralf Hinze, Ross Paterson
   </dt>
   <dd><em>Abstract</em>:We present 2-3 finger trees, a functional representation of persistent sequences supporting access to the ends in amortized constant time, and concatenation and splitting in time logarithmic in the size of the smaller piece. Representations achieving these bounds have appeared previously, but 2-3 finger trees are much simpler, as are the operations on them. Further, by defining the split operation in a general form, we obtain a general purpose data structure that can serve as a sequence, priority queue, search tree, priority search queue and more.
   </dd>
   <dt>
      <q><a href="http://www.amazon.com/gp/product/0691023565?ie=UTF8&amp;tag=siusdesi2-20&amp;linkCode=as2&amp;camp=1789&amp;creative=390957&amp;creativeASIN=0691023565">How to Solve It: A New Aspect of Mathematical Method</a></q>&mdash;G. Polya
   </dt>
   <dt><strong>Updates and other suggestions</strong></dt>
   <dt>
      <q><a href="http://www.amazon.com/gp/product/1589880366?ie=UTF8&tag=siusdesi2-20&linkCode=as2&camp=1789&creative=390957&creativeASIN=1589880366">Infinity: Beyond the Beyond the Beyond</a>&mdash;Lillian R. Lieber</q>
   </dt>
   <dt>
      <q><a href="http://www.amazon.com/gp/product/1589880331?ie=UTF8&tag=siusdesi2-20&linkCode=as2&camp=1789&creative=390957&creativeASIN=1589880331">The Education of T.C. Mits: What modern mathematics means to you</a>&mdash;Lillian R. Lieber</q>
   </dt>
   <dt>
      <q><a href="http://www.amazon.com/gp/product/1589880447?ie=UTF8&tag=siusdesi2-20&linkCode=as2&camp=1789&creative=390957&creativeASIN=1589880447">The Einstein Theory of Relativity: A Trip to the Fourth Dimension</a></q>&mdash;Lillian R. Lieber
   </dt>
</dl>
]]></content></entry>
<entry><title>This is not the Freehackers Union...</title><link href="http://sigusr2.net/2010/Oct/12/this-is-not-the-freehackers-union.html"/><id>md5:39d499a59be2c0995aa1b553a103ed50</id><updated>2010-10-12T00:00:00Z</updated><content type="html"><![CDATA[<p><em>I work at <a href="http://www.meetup.com/">Meetup</a>, but the opinions expressed in here are my own, and do not necessarily represent the opinions of Meetup.</em></p>

<p><span class="preamble">Zed Shaw had a <a href="http://www.zedshaw.com/essays/the_freehackers_union.html">dream</a>, and that dream <a href="http://www.zedshaw.com/blog/2009-03-16.html">failed</a>, but I'm trying again and at least for now succeeding.</span></p>

<p>When the <a href="http://www.zedshaw.com/essays/the_freehackers_union.html">Freehackers Union post</a> came out and it starting getting some attention, I was completely stoked. I couldn't wait to move to NYC (I was moving anyway) and show off my hack<sup><a href="#note-1">[1]</a></sup> and gain acceptance into the group. Of course, by the time I actually got here, the F.U. had dissipated.</p>

<p>I have to be honest, I did think Zed was exaggerating quite a bit when he described his frustrations attending tech events, but as I started getting involved in the NYC tech scene, I too felt the same way.</p>

<p>But, Zed was right&mdash;NYC tech groups and events suck. OK, maybe that's a bit harsh, because there <a href="http://lispnyc.org/home.clp">are</a> <a href="http://nycpython.org/">great</a> <a href="http://www.meetup.com/Clojure-NYC/">ones</a> <a href="http://www.meetup.com/NYC-Tech-Talks/">out</a> <a href="http://www.meetup.com/ny-scala">there</a><sup><a href="#note-2">[2]</a></sup>, but even the ones I like suffer from business people, and even worse, <em>horrible</em> tech recruiters.</p>

<p>Tech events also suffer from too much company promotion and not enough about the actual tech. I can't count how many times I've sat through a 15 minute sermon on Product X that lasted <em>25 minutes</em> due to the inability of the organizer, whether due to politeness or interest, to keep to the scheduled time slot. Worse yet, the speaker gives a sales pitch, hoping to get the audience on board to purchase it, or in the case of it being some Company X's "contribution to open source" to become contributors. It's just not useful to me<sup><a href="#note-3">[3]</a></sup>.
</p>

<p>In fact, the best talks at any tech event I've ever been to are just 5 minutes (dubbed <a href="http://en.wikipedia.org/wiki/Lightning_Talk">Lightning Talks</a>). Five minutes isn't a lot of time, but it is more than enough time to convince an audience that they should check something out, or <em>show off</em> something cool that they have built. It also happens to be the format that the F.U. used. Why? Because Zed is an intelligent guy&mdash;he too knows that 5 minutes is a perfect amount of time for a talk.</p>

<p>But why? It's quite simple really. If the talk sucks, or doesn't interest you, it is only 5 minutes of your life gone. However, if the talk is good or of interest to you, there is always time later to get together and discuss it further.</p>

<h3>Hack and Tell</h3>

<p>In August, I started NYC's <a href="http://hackandtell.org/">Hack and Tell</a>, a show and tell for hackers. It's an experiment, attempting to answer the question: "Can a relaxed Freehackers Union, with a few new rules actually work?" So far the answer has been "Hell yeah! It can totally thrive!" All 3 events have had great turn outs, with great projects being presented.</p>

<p>The rules are simple. You get 5 minutes<sup><a href="#note-4">[4]</a></sup>to show off whatever it is you are doing (hardware, library X, programming language, build tool, visualization, hack, whatever), and the audience gets 5 minutes to give you praise, tell you "you suck"<sup><a href="#note-5">[5]</a></sup>, ask a question, or offer advice. The only other rules are "No Startup pitches", "No Deckware" and keep your work at work&mdash;we want to see personal projects.</p>

<p>We also do not allow the resources of the group to be utilized for recruiting purposes. As a result, we see next to no recruiters<sup><a href="#note-6">[6]</a></sup>, and I, on occasion, have received emails from members wanting to promote something, asking if it was OK to do so<sup><a href="#note-7">[7]</a></sup>.</p>

<p>I'm not sure how long the quiet time will last, (or even how long I can successfully keep it running) but my hope is that strict enforcement of the core rules will keep it fun and a great addition to the NYC tech community.</p>

<h4>This sounds wonderful, but what are the issues?</h4>

<p>Aside from the aforementioned recruiter, we've had very few interruptions to the flow and development of an awesome group, but I do see some problems starting to show.</p>

<p>For one, the group's membership, and attendance is starting to grow due to word of mouth and more exposure from local NYC mailing lists such as <a href="http://www.garysguide.org/">Gary's Guide</a> and <a href="http://startupdigest.com/">Startup Digest</a>.</p>

<p>This is both a blessing and a curse. It is a blessing because we have a larger pool of developers to show off their projects. But, it is also a curse because not everyone that joins will become a presenter, whether due to lack of technical knowledge or lack of time outside of work to build things to show off. The curse actually can get worse of course, because there is not a clear reason for them (i.e. the non-contributors) to attend. What do these folks actually want to get from Hack and Tell?</p>

<p>It is quite possible that they'll become members for recruiting reasons, or other reasons that I have not quite discovered yet, but if they are not building stuff in their free time, do they belong? I don't know, but this question certainly on my mind, and it is certainly a worry.</p>

<p>Ultimately, I think that some pool of non-presenters is healthy, and I believe that the pool is ultimately contributing positively, at least in some cases. The group of non-presenters most likely has something else to contribute&mdash;maybe they are well connected and can be a megaphone to people in other cities, or even within NYC&mdash;which we certainly need, at least now, to attract more great projects to be presented. But, that can't be true of the entire non-presenter pool. There has to be leechers. Again, I don't have the answers.</p>

<p>I'm more than happy to hear anyone and everyone's thought on the matter, share more of my experiences and help other people get a Hack and Tell started in their city, if they'd like. I'm certainly willing to setup another means of conversation as well if anyone is interested.</p>

<p><strong>More discussion:</strong> <a href="http://news.ycombinator.com/item?id=1785627">Hacker News</a></p>

<p><strong>Zed responds</strong> at <a href="http://oppugn.us/posts/1286944278.html">FU NYC</a></p>

<ol class="footnotes">
   <li id="note-1">I didn't actually have a hack to show off, but I figured I'd come up with something, and hoped it'd be enough value to get me in</li>
   <li id="note-2">And many more that are good but not great. Of course, I haven't been to <em>all</em> the events or groups in NYC, so this is just my personal experience.</li>
   <li id="note-3">The product <em>might</em> actually be useful to me, but a 5 minute sales pitch with a link to more detail, it's design, some use cases etc. would be <em>more</em> useful because the speaker probably isn't answering my lower-level questions anyway, and it's shorter so I'll actually listen.</li>
   <li id="note-4">This is strictly enforced, and we normally use a <a href="http://hackandtell.org/timer">timer</a> (<a href="http://github.com/apgwoz/timer/">source</a>)&mdash;it's a bit buggy but it works great most of the time) which claps at the end. This serves two purposes; it prompts the the audience to clap, and it means that no one has to be rude to stop the presenter.</li>
   <li id="note-5">So far, this hasn't happened.</li>
   <li id="note-6">One company tried, and were pummeled with a wall of text explaining how stupid it is to target intelligent developers&mdash;the kind of people that'd almost certainly check the recruiting company's website if they were interested.</li>
   <li id="note-7">In most cases, the post was inappropriate, as it related to promotion of a startup, which of course is work related.</li>
</ol>


]]></content></entry>
<entry><title>Google Spreadsheets: Game of Life</title><link href="http://sigusr2.net/2010/Jun/25/google-spreadsheets-game-of-life.html"/><id>md5:026e9ae419696af7421a97f140a267e1</id><updated>2010-06-25T00:00:00Z</updated><content type="html"><![CDATA[<p><span class="preamble">Google Docs has become an incredibly useful tool for businesses looking to cut costs on software and infrastructure, and it just keeps getting better.</span></p>

<p>For years, many businesses were tied to Microsoft Windows due to macros that they made use of in Excel and Word, but that's about to change. Recently, Google Spreadsheets released "<a href="http://www.google.com/google-d-s/scripts/scripts.html">Apps Script</a>," which allows you to extend Spreadsheets and/or integrate other Google products like Calendar.</p>

<p>Apps Scripts are written in JavaScript and the environment provides you with a bunch of different <a href="http://www.google.com/google-d-s/scripts/guide_chapter_01.html">services</a>, which allow you to access your contacts, maps, XML, fetch URLs from the Internet, get Google finance information, send email&mdash;all sorts of things that make it possible to create complicated workflows and applications. I can imagine that there will be a marketplace sometime soon, which will be bustling with great apps to buy and use.</p>

<p>For now though, you're on your own.</p>

<p>Anyway, yesterday, Google had a hackathon, and because I had no real business oriented application ideas I thought I'd make a game. The trouble is, all processing is done on the server side, so real time interaction is a bit difficult&mdash;if not impossible. There are timer events, form events and menu events, but you can't bind a key or anything like that&mdash;at least not that I know of.</p>

<p>So, a game like Tetris or Snake was out, but not Conway's classic <a href="http://en.wikipedia.org/wiki/Conway's_Game_of_Life">Game of Life</a>. The Game of Life is a zero-player game in which the initial board evolves to form interesting patterns or disappears into nothing. It's normally drawn on a grid of some sort, so I thought a spreadsheet was appropriate.</p>

<p><img src="http://files.sigusr2.net/images/game-of-life-gosper.png" /></p>

<p>I've put the source code up on <a href="http://github.com/apgwoz/app-script-game-of-life">GitHub</a>, along with some more instructions if you wanna check it out. Fork it.</p>
]]></content></entry>
<entry><title>Code Blogging: ARGF in Python</title><link href="http://sigusr2.net/2010/Jun/23/argf.html"/><id>md5:9d5ba6e7df3fe6f44b607a6a0be06952</id><updated>2010-06-23T00:00:00Z</updated><content type="html"><![CDATA[<pre><code class="python">"""ARGF from Ruby in Python.
Released into the public domain by Andrew Gwozdziewycz, 2010
"""

import sys, os


class _ARGF(object):

    def __init__(self):
        self.lineno = 0
        self.file = None

    def __iter__(self):
        return self.next()

    def next(self):
        files = filter(os.path.isfile, sys.argv[1:])
        pairs = [(f, open(f)) for f in files] \
            if files else [('STDIN', sys.stdin)]
            
        for name, fobj in pairs:
            self.file = name

            for line in fobj.xreadlines():
                self.file = 'STDIN'
                self.lineno += 1
                yield line

ARGF = _ARGF()
</code></pre>

<p><strong>Update:</strong> It was pointed out that I didn't handle <code class="inline">lineno</code> correctly; I fixed it.</p>
]]></content></entry>
<entry><title>Maps are Broken, for Some Definition of Broken</title><link href="http://sigusr2.net/2010/Jun/22/maps-are-broken-for-some-definition-of-broken.html"/><id>md5:ee8c78a17c21d8d986ea5f7e3bc78811</id><updated>2010-06-22T00:00:00Z</updated><content type="html"><![CDATA[<p><span class="preamble">Map datatypes are extremely useful for a variety of tasks in programming. But, they are often painful to use; take for example the following task.</span></p>

<p>In Java, I have a <a href="http://java.sun.com/j2se/1.5.0/docs/api/java/util/HashMap.html">HashMap</a> and I wish to get a random key. Well, <a href="http://java.sun.com/j2se/1.5.0/docs/api/java/util/AbstractMap.html">AbstractMap</a> doesn't define a way to get a random key, but it does provide a way to get a <a href="http://java.sun.com/j2se/1.5.0/docs/api/java/util/Set.html">Set</a> of keys. Does Set have a way to get a random element? No, but you can create an Array from a Set with the <code class="inline">toArray()</code> method on Set.</p>

<p>We end up with the following:</p>

<pre><code>public String randomKey() {
    // Assuming: map = HashMap&lt;String, String&gt;;
    Set&lt;String&gt; set = map.keySet();
    Object[] strings = set.toArray();
    Random random = new Random();
    if (strings.length &gt; 0) {
        return (String)strings[random.nextInt(strings.length)];
    }
    return null;
}
</code></pre>

<p>Now, this isn't necessarily bad, but we have to create a new array, and a new set each time we want a random key. We can of course be smarter about this by caching the array and/or set, but then we run into synchronization issues. We also get screwed when we attempt to implement the <code class="inline">popRandom()</code> operation, which could be implemented like so:</p>

<pre><code>public String popRandom() {
    String key = randomKey();
    if (key != null) {
        String value = map.get(key);
        map.remove(key);
        return value;
    }
    return null; // or more appropriately, throw an exception
}
</code></pre>

<p>So, we're doing all this extra copying, allocating and deleting, when all we really need is an iterator, to solve this generically in <code class="inline">O(n)</code> time.</p>

<pre><code>public String randomKey() {
    // randomKey method in O(n) using imaginary iterator() on AbstractMap
    int size = map.size();
    if (size &gt; 0) {
        int index = new Random().randInt(size);
        Iterator&lt;String&gt; keys = map.iterator();
        while (keys.hasNext()) {
           if (index-- == 0) {
               return keys.next();
           }
           keys.next();
        }
    }
    return null;
}
</code></pre>


<p>This sort of thing isn't necessarily true for dynamic languages like Python which normally have ways to iterate over keys in a map, dictionary or set. They still don't have a way to get a random element from either out of the box without resulting to the <code class="inline">O(n)</code> iteration method, or converting to a list and using a random index approach.</p>

<pre><code>&gt;&gt;&gt; import random
&gt;&gt;&gt; random.choice(set([1, 2, 3]))
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
  File "/System/Library/Frameworks/Python.framework/Versions/2.5/lib/python2.5/random.py", line 248, in choice
    return seq[int(self.random() * len(seq))]  # raises IndexError if seq is empty
TypeError: 'set' object is unindexable
</code></pre>

<pre><code>&gt;&gt;&gt; random.choice({'1': 'world', '2': 'galaxy', '3': 'universe'})
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
  File "/System/Library/Frameworks/Python.framework/Versions/2.5/lib/python2.5/random.py", line 248, in choice
    return seq[int(self.random() * len(seq))]  # raises IndexError if seq is empty
KeyError: 2
</code></pre>

<p>And of course that makes sense given how <code class="inline">random.choice</code> is implemented, since there's not necessarily  an order for the elements of a set or dictionary, so you can't expect to subscript them. However they do provide an order when iterating over them and traversing the structure they exist in, so you could certainly use the same <code class="inline">O(n)</code> approach from above.</p>

<p>If there's some other less obvious way to do this in Java using a <a href="http://en.wikipedia.org/w/index.php?title=Dependency_injection&oldid=260831402#A_code_illustration_using_Java">EnterpriseFactoryObserverFactoryFactoryCreator</a>, please leave a comment.</p>


<p><strong>Update: I overlooked something important, which was pointed out by <a href="http://news.ycombinator.com/item?id=1452619">gojomo</a> on Hacker News. Set, which is returned from <code class="inline">keySet()</code> on HashMap, has an iterator. Thus:</strong></p>

<pre><code>public String randomKey() {
    int index = random.nextInt(map.size());
    for (String key: map.keySet()) {
        if (index-- == 0) {
            return key;
        }
    }
    return null;
}
</code></pre>
]]></content></entry>
<entry><title>Pattern Matching with "With"</title><link href="http://sigusr2.net/2010/Apr/28/pattern-matching-with-with.html"/><id>md5:862f9d6d39aec112eecc179210926c60</id><updated>2010-04-28T06:29:00Z</updated><content type="html"><![CDATA[<p>
<span class="preamble">When I originally thought about adding pattern matching to Python, in the <a href="http://sigusr2.net/2008/Sep/30/python-type-constructors-like-ocaml.html">OCaml sense</a>, I ended up using a decorator that more or less registed a bunch of callbacks with a dispatch table based on the types of it's arguments.</span>
</p>

<p>That worked out fine, but it didn't really have the feel of <a href="http://en.wikipedia.org/wiki/Pattern_matching">pattern matching</a> like you get with real <a href="http://en.wikipedia.org/wiki/Algebraic_data_type">algebraic data types</a>. If you recall, I was playing with the following example with the decorator approach:
</p>

<pre><code class="ocaml">type astnode = 
| AndNode of astnode * astnode
| OrNode of astnode * astnode
| NotNode of astnode 
| IdNode of bool

let rec eval_node (n: astnode) = 
  match n with
  | AndNode (l, r) -> (eval_node l) && (eval_node r)
  | OrNode (l, r) -> (eval_node l) || (eval_node r)
  | NotNode l -> not (eval_node l)
  | IdNode v -> v

eval_node (AndNode (IdNode true, IdNode false)) (* returns false *)
</code></pre>

<p>The idea of that program was to create a small language to evaluate boolean expressions. In OCaml, it's quite succinct&mdash;too succinct, in all honesty. That's it. Of course it doesn't include a parser, or a lexer, but that's the crux of it.
</p>

<p>Since that original post, I've posted about two other <q>language hacks</q> that I've attempted to create&mdash;both of which use <a href="http://www.python.org/dev/peps/pep-0343/">context managers</a> and the <code class="inline">with</code>-statement, <a href="http://sigusr2.net/2009/Oct/01/python-worlds.html">worlds</a> and <a href="http://sigusr2.net/2009/Mar/04/dispatching-with-with.html">dispatching urls (a la routes)</a>.</p>

<p>Basically, it occurred to me yesterday, that <code class="inline">with</code>'s <code class="inline">as</code> clause did destructuring of tuples, in the same way that the assignment statement does. That is to say:</p>

<pre><code class="python">a, b, c = 1, 2, 3</code></pre>

<p>Will correctly assign <code class="inline">a = 1</code>, <code class="inline">b = 2</code>, <code class="inline">c = 3</code>, in the same exact way that:</p>

<pre><code class="python">from contextlib import contextmanager
@contextmanager
def assign(*args):
    yield args

with assign(1, 2, 3) as (a, b, c,):
    pass
</code></pre>

<p>will assign <code class="inline">a = 1</code>, <code class="inline">b = 2</code>, <code class="inline">c = 3</code>.</p>

<p>I'll admit, that doesn't look very powerful by itself, but when you consider the possibilities, you might come up with something like I did:</p>

<pre><code class="python">with structural_matching((1, 2, 3)) as match:
    with match('list() x y z') as (x, y, z):
        print x, y, z
    with match('tuple() x _ z') as (x, z):
        print "tuple case"
        print x, z
</code></pre>

<p>which looks incredibly close to pattern matching in OCaml. I was super excited&mdash;but it won't work.</p>

<p>See, <code class="inline">match</code> is a context manager that gets returned with the intention that if the <code class="inline">__enter__()</code> method raises a <code class="inline">NoMatch</code> exception, it skips the "body" and goes to the next match. The problem with that thinking however is simple&mdash;there's no way for <code class="inline">__enter__</code> to force skipping the body due to rejected <a href="http://www.python.org/dev/peps/pep-0377/">PEP-377</a>!</p>

<p>In the example above (full source <a href="http://files.sigusr2.net/match1.py">here</a>), raising <code class="inline">NoMatch</code> in the first <code class="inline">match</code> block, results in control being passed back to the <code class="inline">__exit__()</code> of the outer context manager&mdash;<code class="inline">structural_matching</code>. And to think, I got my hopes up!</p>

<p>But nevertheless, I pressed on, and hacked <a href="http://files.sigusr2.net/match2.py">together</a>, a <code class="inline">match</code>, that can destructure the following examples correctly:</p>

<pre><code class="python">with match('[1:3]', [1, 2, 3, 4]) as (a,):
    print a
# [2, 3]

with match('[1:]', "hello world") as (a,):
    print a
# ('e', 'ello world')

with match('str() x y', 'hello world') as (h, e):
    print 'h = ', h, ',',
    print 'e = ', e
# h = h, e = e

with match('x y z', [1, 2, 3]) as (x, y, z,):
    print z, y, x
# 3 2 1

class obj(object):
    def __init__(self, x, y):
        self.x = x
        self.y = y

with match('obj() .x .y', obj('x-ity', 'y-ity')) as (x, y):
    print 'x = ', x, ',',
    print 'y = ', y
# x = x-ity, y = y-ity

with match('x y _', [1, 2, 3]) as (x, y):
    print x, y
# 1, 2
</code></pre>

<p>It's much less useful considering you can't put it in the <code class="inline">structural_match</code> block ,like you would in a <em>real</em> <code class="inline">match</code> statement, but it's all we've got.</p>

<p>Back then, I concluded with <q>This is as close to OCaml like  pattern matching that we're going to get, at least as far as I know how to get, but it's sort of cool, and definitely a hack.</q> Today, I'll conclude the same way.</p>
]]></content></entry>

</feed>