<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom"><title>SIGUSR2: tagged clojure</title><link href="http://sigusr2.net/tags/clojure.xml" rel="self" /><link href="http://sigusr2.net/"/><updated>2011-08-09T15:40:06Z</updated><author><name>Andrew Gwozdziewycz</name></author><id>md5:ec2c8804a8dac6a866e1a43cfce32fc1</id><entry><title>Softserv Serves Requests</title><link href="http://sigusr2.net/2011/Jan/07/softserve-serves-requests.html"/><id>md5:093bb5e2a8d89cf283efb8984e24d0ab</id><updated>2011-01-07T00:00:00Z</updated><content type="html"><![CDATA[<p>
   <span class="preamble">Anyone that knows me knows that I have a lot of projects, most of which are in some sort of unfinished but partially functional state. Then there are others that have a solid 0.1 release, maybe lacking documentation, but usable. There are yet others that never make it to 0.1, and despite my happy thoughts about how this piece of code will change the world, or be the future, it's as good as deadpooled.</span>
</p>

<p>
One project that will certainly not be deadpooled is being developed in my 10% time at work, though on hiatus whilst I resolve some other issues that I inadvertently committed and finish up some other tasks that have higher priority.
</p>

<p>But, I don't wanna discuss that project right now, it is in a sort of discovery phase where I'm attempting to iron out the network protocol, and what functionality it actually provides for its initial run<sup><a href="#note-nonblocking">[1]</a></sup>.</p>

<p>It does, however, do what many servers do&mdash;listen to and accept requests via a socket.</p>

<p>Clojure comes with many ways, of course, to do just that. It is certainly possible to use one of the many frameworks for Java for writing servers, but clojure.contrib/server-socket, looked to be exactly what I needed, and I decided to have a look.</p>

<p>When evaluating any sort of library, the first thing I always do is create something simple that makes use of it. This is not uncommon of course, and the "Hello World" of network programming is the trusted echo server, in which, everything you say will be parroted back to you. That's pretty simple using server-socket:</p>

<pre><code class="clojure">(ns echo
  (:require [clojure.contrib.server-socket :as ss]
            [clojure.contrib.duck-streams :as ds]))

(defn echo-server [in out]
  (binding [*in* (ds/reader in)] <a href="#note-with-in-reader"><sup>[2]</sup></a>
     (ds/with-out-writer out
        (println (read-line)))))

(ss/create-server 1025 echo-server)

(comment
$ echo "HELLO WORLD" | nc 127.0.0.1 1025
HELLO WORLD
$ 
)</code></pre>

<p>Simple enough, but it is unfortunately <em>too</em> simple. For one, it creates a thread per connection, which is just asking for trouble with a public server. Secondly, since it only gives you an <code class="inline">InputStream</code> (<code class="inline">in</code>) and an <code class="inline">OutputStream</code> (<code class="inline">out</code>), there isn't a way to log who connected, or anything about the user who connected other than time. Hell, there's nothing guaranteeing that you're even connecting via a network for this!</p>

<p>Now, I understand that <code class="inline">server-socket</code> was not really meant for production use&mdash;it is meant for quick toying around, and testing out ideas as quickly as possible, something it does extremely well, but with a little bit of modification, I think it can be almost just as simple and still be suitable for production use.

<p>Enter <a href="http://github.com/apgwoz/softserv">softserv</a>, a still simple, but slightly more complicated replacement for server-socket.</p>

<p>So what is more complicated about it? Let's look at "Hello World" and find out:</p>

<pre><code class="clojure">(ns echo
  (:use [softserv.core :only (create-server
                              defservice
                              defhandler
                              with-shutdown)])
  (:require [clojure.contrib.duck-streams :as ds]))

(defn echo-parser [s]
  (binding [*in* (ds/reader s)]
    {:data (read-line) :type :echo}))

(defservice echo-server :type echo-parser)

(defhandler echo-server :echo
  [s req]
  (with-shutdown s
    (ds/with-out-writer s
      (println (:data req)))))

(create-server 1025 echo-server 10)

(comment
$ echo "HELLO WORLD" | nc 127.0.0.1 1025
HELLO WORLD
)</code></pre>

<p>Phew! That was a mess of code to write to get a simple echo server, surely softserv isn't so, well, soft? Just look at what we've gained, though!</p>

<p>First and foremost, we've gained the ability to specify a maximum number of threads to create. That's what the <code class="inline">10</code> is for in <code class="inline">create-server</code>. Softserv executes request handlers in a thread pool. This of course has some limitations over the thread-per-connection model (like making it harder to allow for long running session based servers), but for resource constrained single request services, it's probably a plus. Maybe relaxing this requirement and figuring out an appropriate way to handle long running connections is a good next step.</p>

<p>Secondly, and without any hit in the number of symbols or parentheses, we're passing an actual socket object to the function that does the handling. You'd think that we'd have to call <code class="inline">(.getInputStream s)</code>, but <code class="inline">duck-streams</code> knows how to get an <code class="inline">InputStream</code> for a <code class="inline">Socket</code>. This is almost identical to the original example.</p>

<p>Third, and most importantly, we've made it possible to dispatch based on the type of request. Softserv enforces what you'd have done anyway. The handler function that <code class="inline">server-socket/create-server</code> takes in almost all cases will end up being a <code class="inline">cond</code> statement dispatching to other functions. Softserv just makes that explicit and up front.</p>

<p>Enough chatter, how can I make use of it? Well, our echo server would be much more interesting if in fact we echoed back more interesting things. For instance, we could translate the input, or rot-13 the input, or for ease of illustrative purposes echo back the actual date, a more useful echo, when someone sends the string "DATE".</p>

<pre><code class="clojure">(ns echo
   (:use [softserv.core :only (create-server
                               defservice
                               defhandler
                               with-shutdown)])
<span style="color: red;">-  (:require [clojure.contrib.duck-streams :as ds]))</span>
<span style="color: green;">+  (:require [clojure.contrib.duck-streams :as ds])</span>
<span style="color: green;">+  (:import [java.util Date]))</span>

(defn echo-parser [s]
  (binding [*in* (ds/reader s)]
<span style="color: red;">-    {:data (read-line) :type :echo}))</span>
<span style="color: green;">+    (let [l (read-line)]</span>
<span style="color: green;">+      (assoc {:data l} :type (if (= l "DATE") :date :echo)))))</span>

(defservice echo-server :type echo-parser)

<span style="color: green;">+(defhandler echo-server :date</span>
<span style="color: green;">+  [s req]</span>
<span style="color: green;">+  (with-shutdown s</span>
<span style="color: green;">+    (ds/with-out-writer s</span>
<span style="color: green;">+      (println (str (Date.))))))</span>

(create-server 1025 echo-server 10)

(comment
$ echo "HELLO WORLD" | nc 127.0.0.1 1025
HELLO WORLD
$ echo "DATE" | nc 127.0.0.1 1025
Wed Jan 05 08:29:38 EST 2011
)
</code></pre>

<p>Using a single request parsing function of course has its limitations, but in general, network services are not the type of thing that really have diverse request types. The protocol normally allows you to tell within a few bytes what kind of request it is. In the case of softserv servers the handlers can then finish reading the request and taking the appropriate actions.</p>

<p>I'd really appreciate any feedback on this.</p>

<ol class="footnotes">
    <li id="note-nonblocking">There's also the question of non-blocking vs. blocking, but the first pass will be blocking until there are real numbers to look at.</li>
    <li id="note-with-in-reader">I'm not sure of the reasoning, but <code class="inline">(with-in-reader s ...)</code> throws an exception saying java.io.PushbackReader cannot be cast to java.io.BufferedReader. This doesn't seem right to me, since it'd work if it were a LineNumberingPushbackReader, but PushbackReader's don't have a <code class="inline">.readLine</code> method, and don't derive from BufferedReader. Nevertheless, I feel as though read-line should know how to handle it, or wrap the PushbackReader in a LineNumberingPushbackReader temporarily, if that's possible.</li>
</ol>
]]></content></entry>
<entry><title>Clojure Conj Reading List</title><link href="http://sigusr2.net/2010/Oct/24/clojure-conj-reading-list.html"/><id>md5:bf830f7059334bc6e2722078fa36fb07</id><updated>2010-10-24T00:00:00Z</updated><content type="html"><![CDATA[<p>
   <span class="preamble">This past weekend, the first (hopefully annual) <a href="http://first.clojure-conj.org">Clojure Conj</a> took place in Durham, NC.</span></p>
<p>In my opinion, the conference was a great success, and was greatly inspirational, as well as enjoyable in many regards. I left the conference recharged with energy to better learn about and help improve the Clojure ecosystem, and just get more involved. But, that's not all I left with of course. I left with great information and even more pointers to new thoughts, opinions and ideas.</p>

<p>I've compiled a small reading list of things that were mentioned in talks. I also got a chance to (briefly) meet <a href="http://fogus.me">Michael Fogus</a>, whose talk discussed the influences of Clojure and asked him if it would be possible for him to make a reading list. I certainly hope he does. Anyway, here's my list:</p>
<dl>
   <dt>
      <q><a href="http://www.gdmc.nl/publications/2008/MonetDB.pdf">MonetDB, a novel spatial column-store DBMS</a></q>&mdash;Maarten Vermeij, Wilko Quak, Martin Kersten, Niels Nes
   </dt>
   <dd>
      <em>Abstract</em>: Column-store database engines are a promising track in database research to handle data warehouses. In this paper we describe our experiences in extending the open-source database management system MonetDB with geo-spatial functionality. The approach taken is to leverage the existing geo-spatial software library GEOS through the extensibility features of this DBMS. The result is a high-performance solution using a software stack that enables future research and development improvements in many directions. In our paper we first give an overview of the MonetDB architecture then we describe how this architecture is beneficial for the handling of spatial data.
   </dd>
   <dt>
      <q><a href="http://www.st.cs.uni-saarland.de/edu/seminare/2005/advanced-fp/docs/huet-zipper.pdf">The Zipper</a></q>&mdash;Gerard Huet
   </dt>
   <dd>
      <em>Capsule Review</em>: Almost every programmer has faced the problem of representing a tree together with a subtree that is the focus of attention, where that focus may move left, right, up or down the tree. The Zipper is Huet's nifty name for a nifty data structure which fulfills this need. I wish I had known of it when I faced this task, because the solution I came up with was not quite so efficient or elegant as the Zipper.
   </dd>
   <dt>
      <q><a href="http://www.amazon.com/gp/product/0465024114?ie=UTF8&amp;tag=siusdesi2-20&amp;linkCode=as2&amp;camp=1789&amp;creative=390957&amp;creativeASIN=0465024114">Finding Flow: The Psychology of Engagement with Everyday Life</a></q>&mdash;Mihaly Csikszentmihalyi
   </dt>
   <dt>
      <q><a href="http://www.amazon.com/gp/product/0716704633?ie=UTF8&amp;tag=siusdesi2-20&amp;linkCode=as2&amp;camp=1789&amp;creative=390957&amp;creativeASIN=0716704633">Computer Power and Human Reason</a>&mdash;Joseph Weizenbaum</q>
   </dt>
   <dt>
      <q><a href="http://www.soi.city.ac.uk/~ross/papers/FingerTree.pdf">Finger Trees: A Simple General-purpose Data Structure</a></q>&mdash;Ralf Hinze, Ross Paterson
   </dt>
   <dd><em>Abstract</em>:We present 2-3 finger trees, a functional representation of persistent sequences supporting access to the ends in amortized constant time, and concatenation and splitting in time logarithmic in the size of the smaller piece. Representations achieving these bounds have appeared previously, but 2-3 finger trees are much simpler, as are the operations on them. Further, by defining the split operation in a general form, we obtain a general purpose data structure that can serve as a sequence, priority queue, search tree, priority search queue and more.
   </dd>
   <dt>
      <q><a href="http://www.amazon.com/gp/product/0691023565?ie=UTF8&amp;tag=siusdesi2-20&amp;linkCode=as2&amp;camp=1789&amp;creative=390957&amp;creativeASIN=0691023565">How to Solve It: A New Aspect of Mathematical Method</a></q>&mdash;G. Polya
   </dt>
   <dt><strong>Updates and other suggestions</strong></dt>
   <dt>
      <q><a href="http://www.amazon.com/gp/product/1589880366?ie=UTF8&tag=siusdesi2-20&linkCode=as2&camp=1789&creative=390957&creativeASIN=1589880366">Infinity: Beyond the Beyond the Beyond</a>&mdash;Lillian R. Lieber</q>
   </dt>
   <dt>
      <q><a href="http://www.amazon.com/gp/product/1589880331?ie=UTF8&tag=siusdesi2-20&linkCode=as2&camp=1789&creative=390957&creativeASIN=1589880331">The Education of T.C. Mits: What modern mathematics means to you</a>&mdash;Lillian R. Lieber</q>
   </dt>
   <dt>
      <q><a href="http://www.amazon.com/gp/product/1589880447?ie=UTF8&tag=siusdesi2-20&linkCode=as2&camp=1789&creative=390957&creativeASIN=1589880447">The Einstein Theory of Relativity: A Trip to the Fourth Dimension</a></q>&mdash;Lillian R. Lieber
   </dt>
</dl>
]]></content></entry>

</feed>