<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom"><title>SIGUSR2: tagged ocaml</title><link href="http://sigusr2.net/tags/ocaml.xml" rel="self" /><link href="http://sigusr2.net/"/><updated>2011-01-07T19:41:53Z</updated><author><name>Andrew Gwozdziewycz</name></author><id>md5:ec2c8804a8dac6a866e1a43cfce32fc1</id><entry><title>Pattern Matching with "With"</title><link href="/2010/Apr/28/pattern-matching-with-with.html"/><id>md5:862f9d6d39aec112eecc179210926c60</id><updated>2010-04-28T06:29:00Z</updated><content type="html"><![CDATA[<p>
<span class="preamble">When I originally thought about adding pattern matching to Python, in the <a href="http://sigusr2.net/2008/Sep/30/python-type-constructors-like-ocaml.html">OCaml sense</a>, I ended up using a decorator that more or less registed a bunch of callbacks with a dispatch table based on the types of it's arguments.</span>
</p>

<p>That worked out fine, but it didn't really have the feel of <a href="http://en.wikipedia.org/wiki/Pattern_matching">pattern matching</a> like you get with real <a href="http://en.wikipedia.org/wiki/Algebraic_data_type">algebraic data types</a>. If you recall, I was playing with the following example with the decorator approach:
</p>

<pre><code class="ocaml">type astnode = 
| AndNode of astnode * astnode
| OrNode of astnode * astnode
| NotNode of astnode 
| IdNode of bool

let rec eval_node (n: astnode) = 
  match n with
  | AndNode (l, r) -> (eval_node l) && (eval_node r)
  | OrNode (l, r) -> (eval_node l) || (eval_node r)
  | NotNode l -> not (eval_node l)
  | IdNode v -> v

eval_node (AndNode (IdNode true, IdNode false)) (* returns false *)
</code></pre>

<p>The idea of that program was to create a small language to evaluate boolean expressions. In OCaml, it's quite succinct&mdash;too succinct, in all honesty. That's it. Of course it doesn't include a parser, or a lexer, but that's the crux of it.
</p>

<p>Since that original post, I've posted about two other <q>language hacks</q> that I've attempted to create&mdash;both of which use <a href="http://www.python.org/dev/peps/pep-0343/">context managers</a> and the <code class="inline">with</code>-statement, <a href="http://sigusr2.net/2009/Oct/01/python-worlds.html">worlds</a> and <a href="http://sigusr2.net/2009/Mar/04/dispatching-with-with.html">dispatching urls (a la routes)</a>.</p>

<p>Basically, it occurred to me yesterday, that <code class="inline">with</code>'s <code class="inline">as</code> clause did destructuring of tuples, in the same way that the assignment statement does. That is to say:</p>

<pre><code class="python">a, b, c = 1, 2, 3</code></pre>

<p>Will correctly assign <code class="inline">a = 1</code>, <code class="inline">b = 2</code>, <code class="inline">c = 3</code>, in the same exact way that:</p>

<pre><code class="python">from contextlib import contextmanager
@contextmanager
def assign(*args):
    yield args

with assign(1, 2, 3) as (a, b, c,):
    pass
</code></pre>

<p>will assign <code class="inline">a = 1</code>, <code class="inline">b = 2</code>, <code class="inline">c = 3</code>.</p>

<p>I'll admit, that doesn't look very powerful by itself, but when you consider the possibilities, you might come up with something like I did:</p>

<pre><code class="python">with structural_matching((1, 2, 3)) as match:
    with match('list() x y z') as (x, y, z):
        print x, y, z
    with match('tuple() x _ z') as (x, z):
        print "tuple case"
        print x, z
</code></pre>

<p>which looks incredibly close to pattern matching in OCaml. I was super excited&mdash;but it won't work.</p>

<p>See, <code class="inline">match</code> is a context manager that gets returned with the intention that if the <code class="inline">__enter__()</code> method raises a <code class="inline">NoMatch</code> exception, it skips the "body" and goes to the next match. The problem with that thinking however is simple&mdash;there's no way for <code class="inline">__enter__</code> to force skipping the body due to rejected <a href="http://www.python.org/dev/peps/pep-0377/">PEP-377</a>!</p>

<p>In the example above (full source <a href="http://files.sigusr2.net/match1.py">here</a>), raising <code class="inline">NoMatch</code> in the first <code class="inline">match</code> block, results in control being passed back to the <code class="inline">__exit__()</code> of the outer context manager&mdash;<code class="inline">structural_matching</code>. And to think, I got my hopes up!</p>

<p>But nevertheless, I pressed on, and hacked <a href="http://files.sigusr2.net/match2.py">together</a>, a <code class="inline">match</code>, that can destructure the following examples correctly:</p>

<pre><code class="python">with match('[1:3]', [1, 2, 3, 4]) as (a,):
    print a
# [2, 3]

with match('[1:]', "hello world") as (a,):
    print a
# ('e', 'ello world')

with match('str() x y', 'hello world') as (h, e):
    print 'h = ', h, ',',
    print 'e = ', e
# h = h, e = e

with match('x y z', [1, 2, 3]) as (x, y, z,):
    print z, y, x
# 3 2 1

class obj(object):
    def __init__(self, x, y):
        self.x = x
        self.y = y

with match('obj() .x .y', obj('x-ity', 'y-ity')) as (x, y):
    print 'x = ', x, ',',
    print 'y = ', y
# x = x-ity, y = y-ity

with match('x y _', [1, 2, 3]) as (x, y):
    print x, y
# 1, 2
</code></pre>

<p>It's much less useful considering you can't put it in the <code class="inline">structural_match</code> block ,like you would in a <em>real</em> <code class="inline">match</code> statement, but it's all we've got.</p>

<p>Back then, I concluded with <q>This is as close to OCaml like  pattern matching that we're going to get, at least as far as I know how to get, but it's sort of cool, and definitely a hack.</q> Today, I'll conclude the same way.</p>
]]></content></entry>
<entry><title>Python Type Constructors a la OCaml</title><link href="/2008/Sep/30/python-type-constructors-like-ocaml.html"/><id>md5:5c9d3c4e3c5a50bf32b5481935fde949</id><updated>2008-09-30T07:00:00Z</updated><content type="html"><![CDATA[<p>
<span class="preamble">Earlier this summer, I started taking a look at the <a href="http://caml.inria.fr/" title="Objective-Caml">OCaml</a> programming language in anticipation of the compilers class I'm taking this fall.</span>
</p>

<p>OCaml is a strongly, <a href="http://en.wikipedia.org/wiki/Type_system#Static_typing">statically typed</a>, functional language with <a href="http://en.wikipedia.org/wiki/Type_inference">type inference</a>. It's pretty neat, and supports imperative programming as well as object-oriented constructs for when you need them. As a language, I've found few things wrong with it, except for the edit-compile-run cycle (I prefer the edit-run cycle you get in a language like Scheme, or even Python), but OCaml does actually have a toplevel (the toplevel isn't crippled either, but it doesn't seem realistic to not compile for testing, at least I haven't yet found it to be). 
</p>

<p>Anyway, among all the amazing features of OCaml, the two that stand out as being the most useful are pattern matching (on types) and the simplicity of defining new types and creating constructors:</p>

<pre><code class="ocaml">type astnode = 
| AndNode of astnode * astnode
| OrNode of astnode * astnode
| NotNode of astnode 
| IdNode of bool

let rec eval_node (n: astnode) = 
  match n with
  | AndNode (l, r) -> (eval_node l) && (eval_node r)
  | OrNode (l, r) -> (eval_node l) || (eval_node r)
  | NotNode l -> not (eval_node l)
  | IdNode v -> v

eval_node (AndNode (IdNode true, IdNode false)) (* returns false *)
</code></pre>

<p>Of course, the type annotation, <code class="inline">(n: astnode)</code>, is optional due to the type inference engine, but the above example shows a simple example type that might be used when defining a language to do boolean arithmetic. It's quick to see that the combination of type constructors (like the <code class="inline">IdNode</code> above) and pattern matching simplify this incredibly.
</p>

<p>But, we don't get this sort of coolness in Python. No, in Python, we can make classes, but we do not get type checking of any kind, unless of course we do it at runtime manually. That's because Python is <a href="http://en.wikipedia.org/wiki/Type_system#Dynamic_typing">dynamically typed</a>.</p>

<p>On the other hand, if we <em>really</em> want to, we can use the built in functions <code class="inline">isinstance</code> and <code class="inline">type</code> to raise errors when incompatible types are passed along to functions. This is slow, but it works. And, in some cases, like the one I'm about to show, maybe it doesn't matter, if you get certain benefits.</p>

<p>Consider a language, like before, that does boolean arithmetic. It'll support boolean <abbr title="Both true">AND</a> (&amp;), <abbr title="One or the other true">OR</abbr> (|), <abbr title="One or the other true, but not both">XOR</abbr> (^) and NOT (!). A valid expression in this language is of the form <code class="inline">t & !(f | t)</code> which evaluates to <code class="inline">false</code>.</p>

<p>I've created two different parsers for this language. In <a href="http://hg.apgwoz.com/boolinterp/file/0c592ee06c7f/bptuples.py" rel="nofollow">bptuples</a>, I create an <a href="http://en.wikipedia.org/wiki/Abstract_syntax_tree" title="Abstract Syntax Tree">AST</a> using Python tuples of the form <code class="inline">('AndNode', t, f)</code>. In <a href="http://hg.apgwoz.com/boolinterp/file/0c592ee06c7f/bpnodes.py" rel="nofollow">bpnodes</a>, however, I take a more elegant approach when building the <abbr title="Abstract Syntax Tree">AST</abbr>&mdash;I create "OCaml like" type constructors.</p>

<pre><code class="python">
ASTNode = deftype('ASTNode', ())
AndNode = deftype('AndNode', (ASTNode, ASTNode,), ASTNode)
OrNode = deftype('OrNode', (ASTNode, ASTNode,), ASTNode)
XorNode = deftype('XorNode', (ASTNode, ASTNode,), ASTNode)
NotNode = deftype('NotNode', (ASTNode,), ASTNode)
IdNode = deftype('IdNode', (bool,), ASTNode)
</code></pre>

<p>This defines all the Python classes needed at runtime. <code class="inline">deftype</code> takes up to 3 arguments. The first argument is the name of the class, the second is a tuple of classes which it can accept as arguments, and the optional third argument is a parent class to inherit from. The optional third argument is only necessary if you need multiple constructors for the same type, as in the case of our OCaml example above, and this example here.</p>

<p>The code for <code class="inline">deftype</code> is actually pretty simple:</p>

<pre><code class="python">
def deftype(name, types, extends=None):
    class _dtype(object):
        def __init__(self, *args):
            for i, a in enumerate(zip(args, self.types)):
                if isinstance(a[0], a[1]):
                    self.__setattr__('op%d' % i, a[0])
                else:
                    raise TypeError("%s expected argument of type " % \
                                        (self.__class__.__name__,
                                         str(a[1])))
    if extends:
        parents = (_dtype, extends,)
    else:
        parents = (_dtype,)
    return type(name, parents, {'types': types})
</code></pre>

<p>Basically, what it does is use the Python built-in <code class="inline">type</code> to construct a class at runtime with an attribute called <code class="inline">types</code> which holds the class names of the expected arguments to the constructor of the type. On construction, the arguments are enumerated and attributes are created of the form <code class="inline">op0</code>...<code class="inline">opN</code>.</p>

<p>It's a mouthful, for sure, but all that means is that when we construct a new <code class="inline">AndNode</code>, we are sure that the arguments the instance was created with are indeed <code class="inline">ASTNode</code>s, and those nodes are accessible at <code class="inline">op0</code> and <code class="inline">op1</code>.</p>

<p>At a cursory glance, you might be thinking, "but what does this actually do for us?" Well, honestly, not much, but you do get to abstract out some more runtime type checking and do dynamic dispatch with the help of some Python decorators. Observe:</p>

<pre><code class="python">
@multimethod(AndNode)
def interpret(ast):
    return interpret(ast.op0) and interpret(ast.op1)

@multimethod(XorNode)
def interpret(ast):
    left = interpret(ast.op0)
    right = interpret(ast.op1)
    return (left or right) and not (left and right)

@multimethod(OrNode)
def interpret(ast):
    return interpret(ast.op0) or interpret(ast.op1)

@multimethod(NotNode)
def interpret(ast):
    return not interpret(ast.op0)

@multimethod(IdNode)
def interpret(ast):
    return ast.op0
</code></pre>

<p>That's the entire interpreter to walk the AST and evaluate boolean expressions, and is called via <code class="inline">interpret(parseBool(tokenizer('t & ! (t | f)')))</code>.</p>

<p>In the tuple version, it's actually shorter when you use <code class="inline">if</code> statements, but this approach is much more readable in my opinion. The <a href="http://www.artima.com/weblogs/viewpost.jsp?thread=101605">multimethod decorator</a> runs the correct <code class="inline">interpret</code> based on the types of arguments.</p>

<p> This is as close to OCaml like  pattern matching that we're going to get, at least as far as I know how to get, but it's sort of cool, and definitely a hack.</p>


]]></content></entry>

</feed>