<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom"><title>SIGUSR2: tagged emacs</title><link href="http://sigusr2.net/tags/emacs.xml" rel="self" /><link href="http://sigusr2.net/"/><updated>2011-08-09T15:40:06Z</updated><author><name>Andrew Gwozdziewycz</name></author><id>md5:ec2c8804a8dac6a866e1a43cfce32fc1</id><entry><title>unipoint-mode: A minor-mode for Mathematical Unicode</title><link href="http://sigusr2.net/2010/Nov/04/unipoint-minor-mode-for-mathematical-unicode.html"/><id>md5:51002542f1e8ffaff3c09d17aea84c99</id><updated>2010-11-04T00:00:00Z</updated><content type="html"><![CDATA[<p><span class="preamble">Last week I <a href="http://fold.sigusr2.net/2010/10/sir-please-step-away-from-the-asr-33-acm-queue.html">reblogged</a> Poul-Henning Kamp's article <a href="http://queue.acm.org/detail.cfm?id=1871406">"Sir, Please Step away from the ASR-33"</a>.</span></p>

<p>If you haven't read it, do so. It has an interesting outlook on what it means to write code, and asks the question, "why the hell are we stuck in the 60s?" His basic premise is that we're married to ASCII, despite having all sorts of other characters at our disposal via unicode, which provides much clearer and concise possibilities for syntax. He also goes on about how none of us have monochromatic screens, so color could play some role in what our programs mean, as well as arguing that the vertical nature of code is unjustified, since we have column editing.</p>

<p>If you ask me, his other arguments are crap, but the unicode argument is completely valid. There's just one problem, have you ever tried to type unicode? It's a mess. In Emacs, to type &rarr;, it's <code class="inline">C-x 8 RET RIGHTWARDS ARROW RET</code>, or if you know the hex value, <code class="inline">C-x 8 RET 2192 RET</code>. Sure, there are <a href="http://xahlee.org/emacs/emacs_n_unicode.html">other options</a>, but most editors aren't nearly as flexible to customize as Emacs is, so who knows what it's like outside of it&mdash;I can't imagine it's any better.</p>

<p>But, when I commented on the fact that "typing unicode sucks," I was greeted by an email from a friend of mine:</p>

<blockquote><a href="http://racket-lang.org/">DrRacket</a> lets you enter common Unicode characters by typing their
LaTeX name followed by control-\. For example, you type &isin; by typing
"\", "i", "n", "control-\". It's easy enough that I use Unicode in my
code all the time.

I bet it wouldn't be too hard to hack something like this feature into Emacs.<span class="closequote"></span>
<cite>&mdash;<a href="http://users.eecs.northwestern.edu/~clk800/">Casey Klein</a></cite>
</blockquote>

<p>This got me thinking about the problem, and in 20 minutes I had <code class="inline">C-\</code> bound to a function that would read a TeX symbol name from the minibuffer and looked up the unicode character in a table then spit it out. I then began to go on a typing spree, seeing how easy it actually was to use. Of course, this wasn't exactly what Casey had described, but it was close enough, and made it way better than before.</p>

<p>It actually had some great features of it's own, too. For one, it had TAB completion, to cut down on typing. DrRacket didn't have that.</p>

<p>I told Casey about my efforts and mentioned TAB completion and how "this isn't all that bad." Casey was intrigued by the TAB completion, and I wanted to see if <code class="inline">C-\</code> after typing \in was better&mdash;it is, but there's still value some value in the prefixed entry.</p>

<p>So now I had a function bound that would do the right thing. If point was at the end of a word boundary with a \ to the left of it (the word), it'd attempt to convert the sequence to a symbol, otherwise it'd be left alone. If you were in empty space or the completion failed, you'd be asked for the symbol as if you were going the prefix route.</p>

<p>This all worked wonderfully well, and our conversation about why I don't like entering unicode went on; he was still convinced it was woefully easy. I, too, was beginning to see that it's not as painful with the proper tools as I originally thought.</p>

<p>The 43 message thread of back and forth sparked inspiration in him around the idea of completion for DrRacket. His idea was simple, hit <code class="inline">C-\</code> and it'd attempt to complete whatever was before it, or output the longest subsequence of the symbols, prefixed with whatever you typed, in the lookup table. In other words, if you had "\sub" it'd complete to "\subset" because both "\subset" and "\subseteq" are in the lookup table. Hit <code class="inline">C-\</code> again and the substitution to &isin; takes place.</p>

<p>I couldn't help but be inspired to add that behavior to what I had now dubbed <a href="http://github.com/apgwoz/unipoint">unipoint</a>. His <a href="https://github.com/plt/racket/commit/bd0ebc7511c7b66dfdd0b24d68dbe27077a9a7dd">changes</a> went into DrRacket</a>. We both found solace in the fact that typing symbols was a bit easier than it was before.</p>

<p>I'm a lot less scared now to see symbols in code, and certainly advocating for them, so long as they stay mathematical in nature. I can't help but feel, though, that most people see this still as a problem. It's because of this that I recorded a quick screencast tutorial (no audio) of how unipoint is used. Hopefully it does its job in showing that it doesn't have to be so painful, and Kamp's dream will eventually become a reality.</p>

<iframe src="http://player.vimeo.com/video/16461894" width="400" height="300" frameborder="0"></iframe>
]]></content></entry>
<entry><title>ant.el: A Code Walkthrough</title><link href="http://sigusr2.net/2010/Oct/29/ant-el-a-code-walkthrough.html"/><id>md5:190c53e1eb58b5488ccc339134ad7766</id><updated>2010-10-29T00:00:00Z</updated><content type="html"><![CDATA[<p><span class="preamble">In April of last year, I blogged about <a href="http://sigusr2.net/2009/Apr/30/the-power-that-is-gnu-emacs.html">how powerful Emacs</a> is, and shared my enlightenment story.</span></p>

<p>Today, I'm even closer to Emacs than I was before, having an extra year and a half of experience than I did then. My daily interactions with Emacs are still very much in the same vain&mdash;I am still a programmer after all, but I've also discovered some more frustrations which were fairly easy to rectify.</p>

<p>In July of this year, I started <a href="http://www.meetup.com/">a new job</a><sup><a href="#hiring-1">[1]</a></sup>. My role at Meetup has been different in many regards than my previous jobs. It's the first role I've had since entering into the industry that someone doesn't see the output of my code. In fact, if they do see the output of my code, I've sort of failed.<sup><a href="#output-2">[2]</a></sup> It also represents the first time that I've primarily used a compiled language (outside of college), targetted the <a href="http://en.wikipedia.org/wiki/JVM">JVM</a> and used <a href="http://java.sun.com/">Java</a> for the bulk of my work.</p>

<p>Naturally, Emacs could help me. <a href="http://www.gnu.org/software/emacs/manual/html_node/emacs/Compilation-Mode.html">Compilation Mode</a>, for instance allows you to do <code class="inline">M-x compile</code> to run <a href="http://en.wikipedia.org/wiki/Make_(software)">make</a>, or <a href="http://ant.apache.org/">ant</a> (with <code class="inline">-emacs</code>) or some other build tool that generates compilation mode compatible output, that the mode will then mark up and allow you to easily jump to places the compiler thinks<sup><a href="#errors-3">[3]</a></sup> are errors.</p>

<p>Compilation Mode by default is fine, but complicated Java source trees are normally nested quite complexly and ant isn't the greatest at locating a suitable build file. What I needed were some interactive functions that I could use to run ant properly, in Compilation Mode using the project's build file. What I <a href="http://github.com/apgwoz/ant-el">came up with</a> after a few hours, works fairly well.</p>

<p>Basically, instead of <code class="inline">M-x compile</code>, I type <code class="inline">M-x ant</code>, or <code class="inline">M-x ant-compile</code>, or <code class="inline">M-x ant</code> and then TAB complete all the available build targets. This allows me to save some typing, and save some precious brain cells, since I don't have to remember all 40 build targets.</p>

<p>The code is fairly simple, and I think it's a great candidate for a walk through on how to solve your own problems using Emacs Lisp, so I'd like to go through it here.</p>

<p>The code starts out simply enough:</p>

<pre><code class="elisp">(defvar ant-last-task "compile")
(defvar ant-build-file-name "build.xml")
(defvar ant-command "ant -emacs")
(defvar *ant-tasks-cache* '())
(defvar *ant-tasks-command* "grep -e '&lt;target.*name=\"[^\-][^\"]*.*$'")
(defvar ant-tasks-default '("compile" "test" "clean"))</code></pre>

<p>We just define a bunch of global variables that can be overridden by a user if they need to be. We do however create <code class="inline">*ant-tasks-cache*</code> and <code class="inline">*ant-tasks-command*</code> which are meant to be internal state. In elisp, and other Lisps, wrapping * around a variable normally indicates that the variable is special in someway, here it means it's a global and shouldn't be modified outside of the functions defined within.</p>

<p>Next we have a helper function, <code class="inline">ant-find-tasks</code>, which, given a directory, issues a shell command <code class="inline">*ant-tasks-command*</code> that is used to extract the lines from the ant build file that declare targets:</p>

<pre><code class="elisp">(defun ant-find-tasks (directory)
  (let ((output (shell-command-to-string (concat *ant-tasks-command* " "
                                                 directory "/"
                                                 ant-build-file-name))))
    (if (> (length output) 0)
        (mapcar '(lambda (x) (replace-regexp-in-string ".*&lt;target.*name=\"\\([^\-][^\"]*\\).*" "\\1" x)) 
                (split-string output "[\n]"))
      nil)))</code></pre>

<p>Essentially, we first save the output of the shell command that gets built up to the variable <code class="inline">output</code>. If the length of <code class="inline">output</code> is greater than 0, we split the output (<code class="inline">split-string</code>) into individual lines, and iteratively replace the junk in the line with just the name of the target (<code class="inline">replace-regexp-in-string</code>). The only non-obvious thing in here is <code class="inline">mapcar</code> which is a fancy way of transforming a list into another list via the function passed as the first argument.</p>

<p>That gives us all the tasks defined in the build file&mdash;well for most cases anyway. It doesn't handle all possible, valid build.xml files, but should work if the <code class="inline">target</code>'s declaration and name attribute appear on the same line.</p>

<p>When we need a list of tasks for a project, we call <code class="inline">ant-tasks</code>. This function really just caches the returned value of <code class="inline">ant-find-tasks</code> into the global variable <code class="inline">*ant-tasks-cache*</code> for the current project:</p>

<pre><code class="elisp">(defun ant-tasks (directory)
  (let ((tasks (assoc-string directory *ant-tasks-cache*)))
    (or tasks
        (progn 
          (let ((newtasks (or (ant-find-tasks directory) ant-tasks-default)))
            (setq *ant-tasks-cache*
                  (cons (cons directory newtasks) *ant-tasks-cache*))
          newtasks)))))</code></pre>

<p>The only interesting thing about the above code is the use of <code class="inline">or</code>. In Lisp, <code class="inline">or</code> short circuits and returns the first truthy value&mdash;it doesn't convert it to a boolean, so it can easily be used to select the first truthy value from a list of values. That's what's happening there.</p>

<p>I mentioned that I wanted TAB completion on task names so as to not clutter my brain matter with useless task names:</p>

<pre><code class="elisp">(defun ant-get-task (directory)
  (let ((task (completing-read-multiple (concat "Task (default): ") 
                                        (ant-tasks directory))))
    (if (> (length task) 0)
        (mapconcat 'identity task " ")
      "")))</code></pre>

<p>Well, here it is. Emacs has built in completion via the <code class="inline">completing-read</code> function. Here, we want the ability to issue one or more tasks, so we use <code class="inline">completing-read-multiple</code> to get the job done. Notice we're calling our function from above, <code class="inline">ant-tasks</code>.</p>

<p>You'll notice <code class="inline">mapconcat</code> above. It's like <code class="inline">mapcar</code> from above, in that it takes a list of things and transforms them, but instead of returning a new list, it concatenates the elements into a string using the last argument (here just a space) as a separator. <code class="inline">completing-read-multiple</code> returns to us a list, which we need to turn into a string with spaces between the targets in order to issue the build command.</p>

<pre><code class="elisp">(defun ant-find-root (indicator)
  (let ((cwd default-directory))
    (while (and (not (file-exists-p (concat cwd indicator)))
                (not (string-equal (expand-file-name cwd) "/")))
      (setq cwd (concat cwd "../")))
    (if (file-exists-p (concat cwd indicator))
        (expand-file-name cwd)
      nil)))</code></pre>

<p>The above function locates the base directory of the project, given the current file being edited. It just loops up the file system looking for the first directory it finds that has a build file in it. When I originally wrote this function, I didn't realize that Emacs already had this functionality built into it with the function <code class="inline">locate-dominating-file</code>.<sup><a href="#dominating-4">[4]</a></sup>

<p><code class="inline">ant-kill-cache</code>,</p>

<pre><code class="elisp">(defun ant-kill-cache ()
  (interactive)
  (setq *ant-tasks-cache* '()))</code></pre>

<p>does exactly what it says it does. It destroys the cache that is built up from <code class="inline">ant-tasks</code>.

<p>The main entry point, <code class="inline">ant</code>, is fairly trivial as well. It sets the variable <code class="inline">default-directory</code>, which is Emacs' current working directory, to the project directory, reads a task from the reader (if being called interactively) and calls <code class="inline">compile</code>, which is the main entry point into Compilation Mode.</p>

<pre><code class="elisp">(defun ant (&optional task)
  "Run ant `task` in project root directory."
  (interactive)
  (let ((default-directory (ant-find-root ant-build-file-name)))
    (if default-directory
        (let ((task (or task (ant-get-task default-directory))))
          (setq ant-last-task task)
          (compile (concat ant-command " " task)))
      (message "Couldn't find an ant project."))))</code></pre>

<p>In the first code block, there was a variable, <code class="inline">ant-last-task</code>, defined that is used above to store the last target run. After a target is given, it's saved off in there.</p>

<pre><code class="elisp">(defun ant-last ()
  "Run the last ant task in project"
  (interactive)
  (ant (or ant-last-task "")))

(defun ant-compile ()
  (interactive)
  (ant "compile"))

(defun ant-clean ()
  (interactive)
  (ant "clean"))

(defun ant-test ()
  (interactive)
  (ant "test"))</pre></code>

<p>The rest of the code above, just defines some convenient, interactive commands for common targets. <code class="inline">M-x ant-compile</code> will just issue the compile target, likewise for <code class="inline">ant-clean</code>. The only moderately interesting interactive command here is <code class="inline">ant-last</code> which reuses the variable <code class="inline">ant-last-task</code> from above to redo the last compilation.</p>

<p>It doesn't feel like much code, and in all reality it's not. However, it has saved me quite a bit of time, as I don't have to go running to a terminal (either switching buffers, or switching windows entirely) in order to issue an ant task. I just do something I've grown very accustomed to&mdash;I issue another Emacs command, and let Emacs take care of it for me.</p>

<ol class="footnotes">
    <li id="hiring-1">We're hiring for <a href="http://www.meetup.com/jobs">most positions</a>.</li>
    <li id="output-2">Most of what I do is related to our product's infrastructure&mdash;not interaction, and not engineering new features. My work would be visible if some error leaked to your browser, and that'd probably be bad.</li> 
    <li id="errors-3">It's fairly difficult to trick the compiler, but in Java, for instance, you can write type-safe code using Generics that it can't prove is safe. If you do that though, you should make use the SuppressWarnings annotation to tell the compiler it's OK.</li>
    <li id="dominating-4">Actually, I wasn't surprised that Emacs actually had the functionality, just that the name is non-trivial. I gave up looking for it after a couple of minutes and just rolled my own. I'll replace it in a future version, but the existing code works for now.</li>
</ol>
]]></content></entry>
<entry><title>The Power That is GNU Emacs</title><link href="http://sigusr2.net/2009/Apr/30/the-power-that-is-gnu-emacs.html"/><id>md5:5956c986d4c2f11dbf3231b781690d06</id><updated>2009-04-30T00:00:00Z</updated><content type="html"><![CDATA[<p><span class="preamble">If you've never been convinced before that <a href="http://www.gnu.org/software/emacs">Emacs</a> is the text editor in which dreams are made from, or that inside Emacs there are unicorns manipulating your text, don't expect me to convince you. 
</span></p>

<p>I'm not going to sit here and type out a Top 10 list of reasons <em>you</em> should be using GNU Emacs, nor am I going to tell you that you are an idiot for using VI (I was a hardcore, "down with emacs," VI user in the late 90s and early 00s). Instead, I'm going to talk about why Emacs works for <em>me</em>. If you're so inclined to give it a try after reading this, then so be it. Searching <a href="http://www.google.com/search?q=emacs+tutorial" title="Google Search Query for 'emacs tutorial'">Google</a> is bound to get you a ton of good information, or you could just start Emacs by typing <code class="inline">emacs</code> at the terminal and typing <code class="inline">C-h</code> (<code class="inline">C-</code> means hold down the control key and hit <code class="inline">h</code> [in this case]. <code class="inline">M-<em>key</em></code> means hold down the Meta key [ALT on most keyboards] and hit <code class="inline"><em>key</em></code>. If there's not a <code class="inline">-</code> between them, you can release Control or Meta before hitting the <em>key</em>).</p>

<p>I first started using Emacs in the spring of 2003, when an acquaintance at the time suggested that Emacs was superior and that I could even use <a href="http://www.emacswiki.org/emacs/ViperMode" title="Viper Mode - VI keybindings for Emacs">viper-mode</a> to simulate VI. The idea that a text editor was powerful enough to simulate another caught my curiosity. I fired it up, and hit the backspace key. Within moments I was put off when the Emacs equivalent of <a href="http://en.wikipedia.org/wiki/Clippy">Clippy</a>, came to my rescue.</p>

<p>See, Emacs responds logically to <code class="inline">C-h</code>, with "Help." The problem is that on many modern keyboards, the backspace key and <code class="inline">C-h</code> send the same value to the terminal.</p>

<p>So, I fired up <a href="http://www.getfirefox.com">Phoenix</a> (or was it Firebird then? Maybe it was Fireweasel?) and searched Google for "emacs backspace problem." Within .004 seconds I had over 3 million pages telling me how to fix the problem. It said to add:</p>

<code class="lisp">(global-set-key "\C-h" 'delete-backward-char)</code>

<p>to my ~/.emacs file. So, I went to my terminal and did what anyone would have done in my situation&mdash;I typed <code class="inline">vi ~/.emacs</code>, pasted the snippet and <code class="inline">ESC :wq!</code>'d</p>

<p>But, despite my trouble I was intrigued. First of all, I had never seen a Unix program configured the way it was. Why didn't Emacs just use something like <a href="http://en.wikipedia.org/wiki/INI_file">INI</a> files, or some other simple format? Later, I realized that I wasn't just configuring Emacs&mdash;no, I was <em>programming</em> the editor to behave the way <em>I</em> preferred.</p>

<p>And, you'll say, "Well, how is that any different than configuration?" To, which I'll reply, "Every command you invoke, even the command that inserts the letter 'j' into this quote here, is calling a function written in the language I used before to set <code class="inline">C-h</code> to behave the way I preferred."</p>

<p>You see, Emacs isn't a text editor. Emacs is a programming language that you can use to write your <em>own</em> text editor. That's why <code class="inline">viper-mode</code> exists. Someone used Emacs to write VI.</p>

<p>And, as I read more about Emacs, and about all the editors people have written (that is to say, editors for writing C, Perl, Python, etc), I got more excited; that is until I discovered <code class="inline">M-x tetris</code>. Why does my editor need <a href="http://en.wikipedia.org/wiki/Tetris">Tetris</a>? It doesn't, and when I discovered more games, I got even more disgusted.</p>

<p>I'm not going to lie&mdash;not even a little bit, in 2003, Emacs was slow. Machines were getting faster, <a href="http://en.wikipedia.org/wiki/RAM">RAM</a> like always was cheap, but it was torture to type <code class="inline">emacs <em>filename</em></code> more than once a day. The games, and all this bloat were obviously the cause right? Well no. It turns out that Emacs has smart ways to load code, so you can save your precious memory. As a naive user, though, I was a bit upset.</p>

<p>So, off to Google again. "Google, How do I speed up Emacs?" "Well, my young Padawan," Google replied, "you should use the server. Add <code class="inline">(server-start)</code> (<code class="inline">M-x describe-function RET server-start RET</code> if you want more info) to your <code class="inline">~/.emacs</code> file and connect with <code class="inline">emacsclient</code>." This was a few days later, and I had a cheat sheet on my desk, so I didn't escape to the terminal and start up VI. This time, I knew to chord <code class="inline">C-x C-f</code>, make my changes and chord <code class="inline">C-x C-s</code>. Easy-peasy.</p>

<p>The common theme here is that documentation for Emacs was easily accessible and there was a seemingly endless community of people answering questions about common pitfalls when getting started with Emacs. As a newbie, this fact made it extremely easy to want to continue learning, and as an advanced user today (can one ever gain the rank of Emacs expert?) this fact still draws me in.</p>

<p>Emacs has since gotten faster as a result of extremely cheap processing power, but VI of course still wins in startup time. It's not a very good metric for comparing the two pieces of software though. For one, I mentioned that Emacs had a server that you could use to keep Emacs going and connect with <code class="inline">emacsclient</code>, but I should also mention that I hardly ever use it. Emacs has an extensive file browser (with tab-completion!), and support for editing multiple files (called buffers). The other thing Emacs has is a mode called <a href="http://www.gnu.org/software/tramp/">Tramp</a>, which allows Emacs to edit files over <a href="http://www.openssh.com/" title="Secure SHell">SSH</a>, <a href="http://en.wikipedia.org/wiki/FTP" title="File Transfer Protocol">FTP</a> and many more. Since this is the case, keeping one Emacs session alive forever makes startup time nil. VI, on the other hand encourages relaunching with new files. I'm fairly sure modern VIs support editing more than one file at once, but I'm also pretty convinced that most VI users know about 15 things about VI, and multiple file editing isn't one of them.</p>

<p>The reason I even still have <code class="inline lisp">(server-start)</code> in my <code class="inline">~/.emacs</code> has to do with other utilities that need an editor. Invoking <code class="inline">emacsclient <em>filename</em></code> will open <code class="inline"><em>filename</em></code> in the Emacs instance that the server is running in. No startup lag&mdash;but you do unfortunately have to context switch.</p>

<p>Naturally, the Emacs community has solved this problem of context switch for many common cases. One of the places where you're bound to need to startup an editor as a programmer is when interacting with <a href="http://en.wikipedia.org/wiki/Software_configuration_management" title="Source Control Management">SCM</a> tools such as <a href="http://subversion.tigris.org/">Subversion</a>, <a href="http://www.selenic.com/mercurial/wiki/">Mercurial</a> or <a href="http://git-scm.com/">Git</a>. These tools allow you to leave messages when you commit changes back to the repository. Committing is common, as is updating files and working with version control repositories in general, so it's only natural that your editor be version control aware. Emacs is, and uses <a href="http://www.emacswiki.org/emacs/VersionControl"><code class="inline">vc-mode</code></a>.</p>

<p>And the more you think about interactions with computers the more you realize how much of it is still text based. <a href="http://en.wikipedia.org/wiki/IRC">IRC</a>, for instance is entirely text based, so why make it hard on yourself to switch back and forth between running programs when you can switch to an IRC buffer in Emacs? I do that, and it's wonderful.</p>

<p>Todo lists, calendars, calculators, Emacs does it all. It's no wonder that mere mortals joke about Emacs, saying "I'm happy with my operating system, I just want a decent text editor!" I said the same thing, and once I tried it, and took the time to learn it, I could never go back.</p>

<h3>Extending</h3>
<p>Over the years, I've discovered lots of things about Emacs, and new modes to play with. There's a never ending list of things to play with on <a href="http://www.emacswiki.org">EmacsWiki</a> if you're so inclined.
</p>

<p>As a programmer, writing my own enhancements was a matter of learning a bit about <a href="http://en.wikipedia.org/wiki/Emacs_lisp">Emacs Lisp</a>, the <a href="http://en.wikipedia.org/wiki/Lisp_(programming_language)">Lisp</a> dialect that Emacs is built on. Coming from a background in C, Perl and at this point in time Python, I laughed at Lisp. "Why would anyone want to write that many parenthesis?" I've since come to the conclusion that Lisp is the most powerful set of programming languages available, but that is a topic for another day. (It is no coincidence, however that the most powerful text editor is built upon a dialect of the most powerful programming language.)</p>

<p>One of the first things I extended Emacs with was a way to convert Windows text files, which use carriage return and a line feed to something more appropriate for editing on Unix (line feed only). I came up with this with some help from our friend Google:</p>

<code class="lisp">(defun dos2unix ()
  "Convert this entire buffer from MS-DOS text file format to UNIX."
  (interactive)
  (save-excursion
    (goto-char (point-min))
    (replace-regexp "\r$" "" nil)
    (goto-char (1- (point-max)))
    (if (looking-at "\C-z")
        (delete-char 1))))
</code>

<p>I'm fairly certain that I didn't write that completely from scratch, and I know for certain that I lifted the <code class="inline">(if (looking-at...) ...)</code> from the Internet somewhere as I'm not even sure why I would want to delete <code class="inline">C-z</code> characters from the end of the file.</p>

<p>Either way, the point is the same, now, without a context switch to the terminal, and the need to have the dos2unix package installed on my system, I can open a Windows text file and say, <code class="inline">M-x dos2unix</code>, and I'm in business.</p>

<p>Another utility that I decided I needed was the ability to split the current window in a 3/4, 1/4 configuration, instead of the default 1/2, 1/2 that you get when you call <code class="inline">split-window</code>. The result looks something like this:</p>

<code class="lisp">(defun three-quarters-window ()
  "Resizes current window big"
  (interactive)
  (let ((size (- (truncate (* .75 (frame-height))) (window-height))))
    (if (> size 0)
        (enlarge-window size))))
</code>

<p>Bound to a key, <code class="inline">(global-set-key "\C-x7" 'three-quarters-window)</code>, makes it easy to keep an eye on an IRC buffer or something else that's changing a few lines at a time, while remaining relatively focused on the buffer you're really editing.</p>

<p>As I continue to try out new major modes and spend time programming Emacs to behave the way I want it to, it's only natural that my <code class="inline">~/.emacs</code> file has become a bit large and hard to read. So I built something to fix it. I built something that allowed me to separate customizations into logical units. Basically, it works similarly to the <a href="http://en.wikipedia.org/wiki/Init">init</a> process from Unix.</p>

<p>I call my version activator. It's basically a few functions and a few overridable variables that will load a set of files with a specifically formatted file name in some specific location on your file system.</p>

<p>Using it is as simple as including a few lines in your <code class="inline">~/.emacs</code> file:</p>

<code>;;;; Need to tell Emacs which directory has activator.el
(setq load-path (cons <em>path to directory containing activator.el</em> load-path))
(require 'activator)
(activator-start)
</code>

<p>By default activator will look for files in <code class="inline">~/.emacs.d/activator.d/</code> with the file name format <code class="inline"><em>XX</em>description.el</code>, where <em>XX</em> is a two digit number used for dependency resolution. In other words, <code class="inline">00settings.el</code> will be loaded before <code class="inline">01utils.el</code> if you were to have those files in your activator load path.</p>

<p>The code for doing this is surprisingly simple:</p>

<code class="lisp">(defun activator-start ()
  "Starts activator, thereby running all the files in `activator-load-path' 
that match the `activator-filename-pattern`"
  (interactive)
  (if (not (boundp 'activator-load-path))
      (error "Please set `activator-load-path`")
    (mapcar 'activator-load-file (activator-get-files))))

(defun activator-get-files (&optional path pattern)
  "Gets files from path specified by `activator-load-path', or from the 
optional path"
  (let ((path (or path activator-load-path))
        (pattern (or pattern activator-filename-pattern)))
    (directory-files path t pattern)))

(defun activator-load-file (file)
  (load-file file))
</code>

<p>Of course, the <a href="http://gitorious.com/projects/emacs-configuration/repos/mainline/blobs/master/activator.el">real code</a> defines the variables <code class="inline">activator-filename-pattern</code> and <code class="inline">activator-load-path</code>, which must be overridden before <code class="inline">(activator-start)</code> is run, should you decide you want to change them.</p>

<p>But, the real power in this is that I can rename configuration files to something that doesn't match the filename pattern if I don't want them to load, say because my configuration needs to be different at work, rather than at home. This makes my Emacs customizations pretty portable, and with a few more tweaks to the way activator works, I could make it even more portable.</p>

<p>I'm not going to be naive and think that I'm the first one to come up with something like this. I know for sure I'm not, and the only reason I did it myself was for the exercise of writing Emacs Lisp. All my customizations to Emacs are loaded currently with activator on all the machines that I use Emacs on. It's pretty great.</p>

<p>As a programmer who spends many hours a day using a text editor, the companionship that Emacs provides is a joy, and our relationship just keeps growing better as I uncover the stories and talents, my little friend has to share. </p>
]]></content></entry>

</feed>