<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom"><title>SIGUSR2: tagged with</title><link href="http://sigusr2.net/tags/with.xml" rel="self" /><link href="http://sigusr2.net/"/><updated>2011-01-07T19:41:53Z</updated><author><name>Andrew Gwozdziewycz</name></author><id>md5:ec2c8804a8dac6a866e1a43cfce32fc1</id><entry><title>Pattern Matching with "With"</title><link href="/2010/Apr/28/pattern-matching-with-with.html"/><id>md5:862f9d6d39aec112eecc179210926c60</id><updated>2010-04-28T06:29:00Z</updated><content type="html"><![CDATA[<p>
<span class="preamble">When I originally thought about adding pattern matching to Python, in the <a href="http://sigusr2.net/2008/Sep/30/python-type-constructors-like-ocaml.html">OCaml sense</a>, I ended up using a decorator that more or less registed a bunch of callbacks with a dispatch table based on the types of it's arguments.</span>
</p>

<p>That worked out fine, but it didn't really have the feel of <a href="http://en.wikipedia.org/wiki/Pattern_matching">pattern matching</a> like you get with real <a href="http://en.wikipedia.org/wiki/Algebraic_data_type">algebraic data types</a>. If you recall, I was playing with the following example with the decorator approach:
</p>

<pre><code class="ocaml">type astnode = 
| AndNode of astnode * astnode
| OrNode of astnode * astnode
| NotNode of astnode 
| IdNode of bool

let rec eval_node (n: astnode) = 
  match n with
  | AndNode (l, r) -> (eval_node l) && (eval_node r)
  | OrNode (l, r) -> (eval_node l) || (eval_node r)
  | NotNode l -> not (eval_node l)
  | IdNode v -> v

eval_node (AndNode (IdNode true, IdNode false)) (* returns false *)
</code></pre>

<p>The idea of that program was to create a small language to evaluate boolean expressions. In OCaml, it's quite succinct&mdash;too succinct, in all honesty. That's it. Of course it doesn't include a parser, or a lexer, but that's the crux of it.
</p>

<p>Since that original post, I've posted about two other <q>language hacks</q> that I've attempted to create&mdash;both of which use <a href="http://www.python.org/dev/peps/pep-0343/">context managers</a> and the <code class="inline">with</code>-statement, <a href="http://sigusr2.net/2009/Oct/01/python-worlds.html">worlds</a> and <a href="http://sigusr2.net/2009/Mar/04/dispatching-with-with.html">dispatching urls (a la routes)</a>.</p>

<p>Basically, it occurred to me yesterday, that <code class="inline">with</code>'s <code class="inline">as</code> clause did destructuring of tuples, in the same way that the assignment statement does. That is to say:</p>

<pre><code class="python">a, b, c = 1, 2, 3</code></pre>

<p>Will correctly assign <code class="inline">a = 1</code>, <code class="inline">b = 2</code>, <code class="inline">c = 3</code>, in the same exact way that:</p>

<pre><code class="python">from contextlib import contextmanager
@contextmanager
def assign(*args):
    yield args

with assign(1, 2, 3) as (a, b, c,):
    pass
</code></pre>

<p>will assign <code class="inline">a = 1</code>, <code class="inline">b = 2</code>, <code class="inline">c = 3</code>.</p>

<p>I'll admit, that doesn't look very powerful by itself, but when you consider the possibilities, you might come up with something like I did:</p>

<pre><code class="python">with structural_matching((1, 2, 3)) as match:
    with match('list() x y z') as (x, y, z):
        print x, y, z
    with match('tuple() x _ z') as (x, z):
        print "tuple case"
        print x, z
</code></pre>

<p>which looks incredibly close to pattern matching in OCaml. I was super excited&mdash;but it won't work.</p>

<p>See, <code class="inline">match</code> is a context manager that gets returned with the intention that if the <code class="inline">__enter__()</code> method raises a <code class="inline">NoMatch</code> exception, it skips the "body" and goes to the next match. The problem with that thinking however is simple&mdash;there's no way for <code class="inline">__enter__</code> to force skipping the body due to rejected <a href="http://www.python.org/dev/peps/pep-0377/">PEP-377</a>!</p>

<p>In the example above (full source <a href="http://files.sigusr2.net/match1.py">here</a>), raising <code class="inline">NoMatch</code> in the first <code class="inline">match</code> block, results in control being passed back to the <code class="inline">__exit__()</code> of the outer context manager&mdash;<code class="inline">structural_matching</code>. And to think, I got my hopes up!</p>

<p>But nevertheless, I pressed on, and hacked <a href="http://files.sigusr2.net/match2.py">together</a>, a <code class="inline">match</code>, that can destructure the following examples correctly:</p>

<pre><code class="python">with match('[1:3]', [1, 2, 3, 4]) as (a,):
    print a
# [2, 3]

with match('[1:]', "hello world") as (a,):
    print a
# ('e', 'ello world')

with match('str() x y', 'hello world') as (h, e):
    print 'h = ', h, ',',
    print 'e = ', e
# h = h, e = e

with match('x y z', [1, 2, 3]) as (x, y, z,):
    print z, y, x
# 3 2 1

class obj(object):
    def __init__(self, x, y):
        self.x = x
        self.y = y

with match('obj() .x .y', obj('x-ity', 'y-ity')) as (x, y):
    print 'x = ', x, ',',
    print 'y = ', y
# x = x-ity, y = y-ity

with match('x y _', [1, 2, 3]) as (x, y):
    print x, y
# 1, 2
</code></pre>

<p>It's much less useful considering you can't put it in the <code class="inline">structural_match</code> block ,like you would in a <em>real</em> <code class="inline">match</code> statement, but it's all we've got.</p>

<p>Back then, I concluded with <q>This is as close to OCaml like  pattern matching that we're going to get, at least as far as I know how to get, but it's sort of cool, and definitely a hack.</q> Today, I'll conclude the same way.</p>
]]></content></entry>
<entry><title>Dispatching With "with"</title><link href="/2009/Mar/04/dispatching-with-with.html"/><id>md5:c47b741e6d7072c9b14a6d5f74c671f1</id><updated>2009-03-04T08:15:00Z</updated><content type="html"><![CDATA[<p>
<span class="preamble">Since <a href="http://www.python.org">Python</a> 2.5, we've had access to a new contstruct called the <a href="http://www.python.org/dev/peps/pep-0343/"><code class="inline">with</code></a>-statement. Using them is as simple as implementing the <a href="http://www.python.org/doc/2.5.2/lib/typecontextmanager.html">context manager protocol</a> for classes.
</span>
</p>

<p>The <code class="inline">with</code>-statement makes it possible to factor our <code class="inline">try</code>/<code class="inline">finally</code> statements that are commonly used to clean up resources created temporarily. Suppose for example, you have a multi-threaded application that makes use of mutexes to guard shared information. As a general rule, once you lock and perform the update on the shared variable, you need to unlock. Failure to unlock can lead to horrible problems, such as starvation or some other inconsistent state. 
</p>

<p>And, what happens if an exception occurs before you unlock? Quite frankly, you're out of luck unless you use <code class="inline">try</code>/<code class="inline">finally</code> to clean up regardless of what happens. It might look something like this:</p>

<code class="python">lock.lock()
try:
    # perform some action
finally:
    lock.unlock()
</code>

<p>This ensures that <code class="inline">lock</code> is unlocked after the action is performed.</p>

<p>Now, using the <code class="inline">with</code>-statement we get something more like:</p>
<code class="python">with lock:
    # perform some action
</code>

<p>The beauty is that we don't have to worry about remembering to call <code class="inline">unlock</code>, or wrap it up in the <code class="inline">try</code>/<code class="inline">finally</code> block. It does it for us.</p>

<p>But, we're not worried about locks here. We're interested in using <code class="inline">with</code> for another purpose, dispatching based on a requested url.</p>

<h3>URL Dispatching</h3>

<p>In many web frameworks these days for Python, such as <a href="http://webpy.org">web.py</a>, resources are dispatched to based on a regular expression that gets matched against the REQUEST_URI environment variable. This is normally pretty powerful, but in the case of web.py, the way this is specified is often a bit awkward. Take for instance:
</p>

<code class="python">import web

urls = (
    '/([a-zA-Z]*)', 'Hello'
)
app = web.application(urls, globals())

class Hello:
    def GET(self, name):
        if not name:
            name = 'world'
        return "Hello,", name

    def POST(self, name): # name can still be in the url
        i = web.input(name='world')
        return "You posted your name! Hello,", i.name

if __name__ == '__main__':
    app.run()
</code>

<p>which is a whole web application written in web.py. The awkwardness comes from the fact that the regular expression used for dispatch, is in no way connected to the resource itself. It'd be nice to use decorators for this so you could get something like:</p>

<code class="python">@web.expose('/([a-zA-Z]*)')
class Hello:
    ...
</code>

<p>but Python didn't get class decorators til Python 3.0, which many people aren't using yet, the author included. And what's the logic behind <code class="inline">def GET(<strong>self</strong>, ...)</code>? It's required in Python, but is just extraneous when defining a resource for web.py.</p>

<p>What if we implemented the context manager protocol in the object returned by <code class="inline">web.application()</code> above that looked like this (or something similiar):
</p>

<code class="python">import inspect
    --snip--
    def __enter__(self):
        return self

    def __exit__(self, *args):
        frame = inspect.currentframe()
        get = frame.f_back.f_locals.get('get', None)
        post = frame.f_back.f_locals.get('post', None)
        resource = {}
        if get:
            resource['get'] = get
        if post:
            resource['post'] = post

        if not (post or get):
            raise ValueError("with must have a get or post function")
        self._resources.append((re.compile(self._last_url), resource))

        if get:
            del frame.f_back.f_locals['get']
        if post:
            del frame.f_back.f_locals['post']

    def expose(self, url):
        self._last_url = url
        return self

    ...
</code>

<p>Then, the simple hello application instead looks like:</p>

<code class="python">import web

app = web.application()

with app.expose('/([a-zA-Z]*)'):
    def get(name):
        if not name:
            name = 'world'
        return "Hello,", name

    def post(name):
        i = web.input(name='world')
        return "You posted your name! Hello,", i.name

if __name__ == '__main__':
    app.run()
</code>

<p>It's declarative, simple, and eliminates a lot of noise, but we no longer get the packaging, or the ability to easily seperate our resources into multiple files. But, for one file web apps, maybe it's useful.</p>
]]></content></entry>

</feed>