<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom"><title>SIGUSR2: tagged algorithms</title><link href="http://sigusr2.net/tags/algorithms.xml" rel="self" /><link href="http://sigusr2.net/"/><updated>2011-07-01T07:54:35Z</updated><author><name>Andrew Gwozdziewycz</name></author><id>md5:ec2c8804a8dac6a866e1a43cfce32fc1</id><entry><title>Maps are Broken, for Some Definition of Broken</title><link href="http://sigusr2.net/2010/Jun/22/maps-are-broken-for-some-definition-of-broken.html"/><id>md5:ee8c78a17c21d8d986ea5f7e3bc78811</id><updated>2010-06-22T00:00:00Z</updated><content type="html"><![CDATA[<p><span class="preamble">Map datatypes are extremely useful for a variety of tasks in programming. But, they are often painful to use; take for example the following task.</span></p>

<p>In Java, I have a <a href="http://java.sun.com/j2se/1.5.0/docs/api/java/util/HashMap.html">HashMap</a> and I wish to get a random key. Well, <a href="http://java.sun.com/j2se/1.5.0/docs/api/java/util/AbstractMap.html">AbstractMap</a> doesn't define a way to get a random key, but it does provide a way to get a <a href="http://java.sun.com/j2se/1.5.0/docs/api/java/util/Set.html">Set</a> of keys. Does Set have a way to get a random element? No, but you can create an Array from a Set with the <code class="inline">toArray()</code> method on Set.</p>

<p>We end up with the following:</p>

<pre><code>public String randomKey() {
    // Assuming: map = HashMap&lt;String, String&gt;;
    Set&lt;String&gt; set = map.keySet();
    Object[] strings = set.toArray();
    Random random = new Random();
    if (strings.length &gt; 0) {
        return (String)strings[random.nextInt(strings.length)];
    }
    return null;
}
</code></pre>

<p>Now, this isn't necessarily bad, but we have to create a new array, and a new set each time we want a random key. We can of course be smarter about this by caching the array and/or set, but then we run into synchronization issues. We also get screwed when we attempt to implement the <code class="inline">popRandom()</code> operation, which could be implemented like so:</p>

<pre><code>public String popRandom() {
    String key = randomKey();
    if (key != null) {
        String value = map.get(key);
        map.remove(key);
        return value;
    }
    return null; // or more appropriately, throw an exception
}
</code></pre>

<p>So, we're doing all this extra copying, allocating and deleting, when all we really need is an iterator, to solve this generically in <code class="inline">O(n)</code> time.</p>

<pre><code>public String randomKey() {
    // randomKey method in O(n) using imaginary iterator() on AbstractMap
    int size = map.size();
    if (size &gt; 0) {
        int index = new Random().randInt(size);
        Iterator&lt;String&gt; keys = map.iterator();
        while (keys.hasNext()) {
           if (index-- == 0) {
               return keys.next();
           }
           keys.next();
        }
    }
    return null;
}
</code></pre>


<p>This sort of thing isn't necessarily true for dynamic languages like Python which normally have ways to iterate over keys in a map, dictionary or set. They still don't have a way to get a random element from either out of the box without resulting to the <code class="inline">O(n)</code> iteration method, or converting to a list and using a random index approach.</p>

<pre><code>&gt;&gt;&gt; import random
&gt;&gt;&gt; random.choice(set([1, 2, 3]))
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
  File "/System/Library/Frameworks/Python.framework/Versions/2.5/lib/python2.5/random.py", line 248, in choice
    return seq[int(self.random() * len(seq))]  # raises IndexError if seq is empty
TypeError: 'set' object is unindexable
</code></pre>

<pre><code>&gt;&gt;&gt; random.choice({'1': 'world', '2': 'galaxy', '3': 'universe'})
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
  File "/System/Library/Frameworks/Python.framework/Versions/2.5/lib/python2.5/random.py", line 248, in choice
    return seq[int(self.random() * len(seq))]  # raises IndexError if seq is empty
KeyError: 2
</code></pre>

<p>And of course that makes sense given how <code class="inline">random.choice</code> is implemented, since there's not necessarily  an order for the elements of a set or dictionary, so you can't expect to subscript them. However they do provide an order when iterating over them and traversing the structure they exist in, so you could certainly use the same <code class="inline">O(n)</code> approach from above.</p>

<p>If there's some other less obvious way to do this in Java using a <a href="http://en.wikipedia.org/w/index.php?title=Dependency_injection&oldid=260831402#A_code_illustration_using_Java">EnterpriseFactoryObserverFactoryFactoryCreator</a>, please leave a comment.</p>


<p><strong>Update: I overlooked something important, which was pointed out by <a href="http://news.ycombinator.com/item?id=1452619">gojomo</a> on Hacker News. Set, which is returned from <code class="inline">keySet()</code> on HashMap, has an iterator. Thus:</strong></p>

<pre><code>public String randomKey() {
    int index = random.nextInt(map.size());
    for (String key: map.keySet()) {
        if (index-- == 0) {
            return key;
        }
    }
    return null;
}
</code></pre>
]]></content></entry>
<entry><title>Anagrams Predicate</title><link href="http://sigusr2.net/2009/Jan/08/anagrams-predicate.html"/><id>md5:c7c123380fbc5a9934d6d485b0a050aa</id><updated>2009-01-08T00:00:00Z</updated><content type="html"><![CDATA[<p><span class="preamble">Recently, I spent some time thinking about a simple problem. How do you test if two strings are <a href="http://en.wikipedia.org/wiki/Anagram">anagrams</a> of each other?</span></p>

<p>There are many ways, but the naive solution is to simply sort both strings, character-wise, and then compare the results. In <a href="http://www.python.org">Python</a>, you might do that like so (We'll leave out the fact that anagrams are actually real words and phrases. We also work in a case-sensitive manor [e.g. "JimMorrison" and "MrMojoRisin" isn't truthy, though a simple <code class="inline">s.lower()</code> goes a long way.]):</p>

<code class="python">def isAnagram(str1, str2):
    if len(str1) != len(str2): return False
    return sorted(str1) == sorted(str2)
</code>

<p>Here, I'm using <code class="inline">sorted</code>, a Python <code class="inline">__builtin__</code>, that takes an iterable and produces a sorted list of that iterable. I'm then taking advantage of the fact that Python lists can be compared element-wise with the <code class="inline">==</code> operator. Doing this produces a function that will work on any string, and it's simple to see why. Sort the string "parental" and you get "aaelnprt." Sort the string "paternal" and you still get "aaelnprt." Obviously "aaelnprt" and "aaelnprt" are equivalent. This of course returns <code class="inline">False</code> for the strings "snowman" and "iceman" since they don't compare sorted equally (or non-sorted for that matter).</p>

<p>However, this solution isn't the most efficient use of resources. For one, most sorting algorithms are only <em>O(n log n)</em>, which means in the best case <code class="inline">isAnagram</code> is too. It also needs to allocate two lists to store the results returned by <code class="inline">sorted</code>.</p>

<p>There is of course a way to do better. You just have to think about the problem for a little longer than a minute:</p>

<code class="python">def isAnagramN(str1, str2):
    if len(str1) != len(str2): return False
    counts = defaultdict(lambda: [0, 0])

    for c1, c2 in izip(str1, str2):
        counts[c1][0] += 1
        counts[c2][1] += 1

    for k, v in counts.iteritems():
        if v[0] != v[1]:
            return False
    return True
</code>

<p>This code does not allocate proportionally to the size of the strings, but instead on the diversity of the strings. In other words, <code class="inline">isAnagramN("aaaaaaa", "bbbbbbb")</code> allocates 1 defaultdict, and 2 lists of size 2. Why? Because, the algorithm simply counts up how many times each letter occurs in each string. Of course Python also has to allocate the generators to use for <code class="inline">izip</code> and <code class="inline">counts.iteritems()</code>, but that isn't significant. The big win here of course is that given strings of <em>any</em> length, the algorithm uses only as much space as the diversity of the contents contained in the strings!</p>

<p>As if that wasn't a win enough, this algorithm runs in <em>O(n)</em> on the length of the strings!</p>

<p>But, does it actually make a difference? The answer of course is yes. For strings of significant length, <code class="inline">isAnagramN</code> runs almost 2x as fast as <code class="inline">isAnagram</code>.</p>

<p>The proof is in the bacon, so let's take a look at some numbers. Using Python's <code class="inline">timeit</code> module, I tested strings of length 1 through 100,001, incrementing by 10,000 (I've tested other lengths as well, and reach a similar conclusion). At each length, the test was repeated 50 times. The results are below:</p>

<style type="text/css">
td { text-align: right; }
td.win { background-color: #ADFF2F; font-weight: bold;}
td.first { background: #dddddd; font-weight: bold; color: #222222; }
</style>

<table cellspacing="5" style="margin: 0 auto;">
  <thead>
    <tr>
    <th>Length</th>
    <th>Time isAnagram</th>
    <th>Time isAnagramN</th>
    </tr>
  </thead>
  <tbody>
    <tr>
     <td class="first">1</td><td class="win">0.00043511390686</td><td>0.000530958175659</td>
     </tr>
     <tr>
     <td class="first">10001</td><td>0.657309055328</td><td class="win">0.38395690918</td>
     </tr>
     <tr>
     <td class="first">20001</td><td>1.25437283516</td><td class="win">0.793761968613</td>
     </tr>
     <tr>
     <td class="first">30001</td><td>1.91431283951</td><td class="win">1.15374517441</td>
     </tr>
     <tr>
     <td class="first">40001</td><td>2.55181908607</td><td class="win">1.53560996056</td>
     </tr>
     <tr>
     <td class="first">50001</td><td>3.14615797997</td><td class="win">2.07976388931</td>
     </tr>
     <tr>
     <td class="first">60001</td><td>3.76745486259</td><td class="win">2.30041193962</td>
     </tr>
     <tr>
     <td class="first">70001</td><td>4.48913788795</td><td class="win">2.81828999519</td>
     </tr>
     <tr>
     <td class="first">80001</td><td>5.155148983</td><td class="win">3.09482097626</td>
     </tr>
     <tr>
     <td class="first">90001</td><td>5.67185592651</td><td class="win">3.477850914</td>
     </tr>
     <tr>
     <td class="first">100001</td><td>6.33614587784</td><td class="win">3.94285678864</td>
     </tr>
  </tbody>
</table>

<p>
  Download the code: <a href="http://files.sigusr2.net/anagram.py">anagram.py</a>
</p>
]]></content></entry>

</feed>