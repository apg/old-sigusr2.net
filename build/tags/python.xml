<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom"><title>SIGUSR2: tagged python</title><link href="http://sigusr2.net/tags/python.xml" rel="self" /><link href="http://sigusr2.net/"/><updated>2011-04-18T07:15:17Z</updated><author><name>Andrew Gwozdziewycz</name></author><id>md5:ec2c8804a8dac6a866e1a43cfce32fc1</id><entry><title>Parser Combinators Made Simple</title><link href="http://sigusr2.net/2011/Apr/18/parser-combinators-made-simple.html"/><id>md5:2d4da36bd3daa6959e8b4f79b8094fc4</id><updated>2011-04-18T00:00:00Z</updated><content type="html"><![CDATA[<p><span class="preamble">Parsing theory has been around for quite a long time, but it is often thought of as magic by the swarms of people who haven't bothered to read about it, and see how plain and dry it actually is. Algorithms for parsing <a href="http://en.wikipedia.org/wiki/LR_parser">LR(k)</a> grammars (meaning Left-to-right, Right-most derivation, k tokens lookahead) for instance, normally just traverse a state machine that was computed before hand (either by hand, or by using a parser generator such as <a href="http://www.gnu.org/software/bison/">bison</a> or <a href="http://en.wikipedia.org/wiki/Yacc">yacc</a>). Sure, there are many things to trip on, tedious to track down ambiguities, and other issues, but the general theory of parsing has remained unchanged for years&mdash;one might say, it is a solved problem.<sup><a id="return-solvedproblem" href="#note-solvedproblem">[1]</a></span></p>

<p>When learning about parsing for the first time though, the idea of a <a href="http://en.wikipedia.org/wiki/Recursive_descent_parser">recursive descent parser</a> is often taught first. Recursive descent parsers, are relatively simple to reason about, to write and to shoot yourself in the foot with. A simple <a href="http://en.wikipedia.org/wiki/LL_parser">LL(1)</a> parser (meaning Left-to-right, Left-most derivation, 1 token lookahead), for instance, can't parse <a href="http://en.wikipedia.org/wiki/Left_recursion">left-recursive grammars</a>, which is the most natural way to write certain types of grammars<sup><a id="return-leftrecursion" href="#note-leftrecursion">[2]</a></sup>. Typically, when writing a recursive descent parser, the author takes the grammar and produces a function for each production (non-terminal). Each function then reads a token and recurses to the other non-terminals in the grammar reachable from the current production. And, eventually, at the end of the function the sub parts will be combined in such a way that a <a href="http://en.wikipedia.org/wiki/Parse_tree">parse tree</a> will be created.</p>

<p>This sounds boring and tedious, and in fact is. However, there is a useful technique for creating these types of parsers that was developed some time ago<sup><a id="return-hutton1989" href="#note-hutton1989">[3]</a></sup>, which involves composing a small set of functions into more meaningful, more advanced parsers. They still suffer from the same problems as your typical recursive descent parser (as presented), but with some other trickery can be made to overcome those deficiencies (we won't discuss that in this article).</p>

<p>In order to build a parser from the ground up, we need to think about what a parser actually is. In some sense, it is really just a function that takes an input string and produces some result. That result, in order to make any progress should contain the leftover string after consuming some part of it, or in the case of error (i.e. incorrect input), return some value indicating failure. In Python, a natural way to encode both results would be to use <code class="inline">(<em>"matched string"</em>, <em>"leftover string"</em>)</code> or <code class="inline">None</code>. For sanity's sake, let us refer to functions which match this criteria as <em>parser functions</em>.</p>

<p>To start off, we'll write a useful parser function, which at first glance seems pointless, <code class="inline">anychar</code>. <code class="inline">anychar</code> matches <em>any</em> (no trickery here!) character so long as there is at least one character left in the input string. (<strong>Note:</strong> we'll use the variable <code class="inline">strn</code> to always refer to the input string, which represents the <em>string left to parse</em>.)</p>

<pre><code>def anychar(strn):
    if strn == "":
        return None
    return (strn[0], strn[1:])
</code></pre>

<p>It is easy to see that the result of this parser function matches our encoding. If there are no characters left in <code class="inline">strn</code>, then we return the failure condition, <code class="inline">None</code>, otherwise we return a tuple of what we parsed, and the rest of the string which we didn't parse.</p>

<p>It becomes more useful when we pair <code class="inline">anychar</code> with a test against the character it consumes. Enter <code class="inline">chartest</code>, which is a function that creates another parser function, given a predicate (i.e. a function which returns <code class="inline">True</code> or <code class="inline">False</code>).</p>

<pre><code>def chartest(pred):
    def _(strn):
        c = anychar(strn)
        if c and pred(c[0]):
            return (c[0], c[1])
        return None
    return _
</code></pre>

<p>In order to use <code class="inline">chartest</code>, we pass it a predicate, like so:</p>

<pre><code>&gt;&gt;&gt; chartest(lambda x: x == 'a')('abc')
('a', 'bc')
</code></pre>

<p>To see what happened, remember that <code class="inline">chartest</code> <em>creates</em> a new parser function. With that, we just call the new parser function with the rest of the input string <code class="inline">'abc'</code>. The result indicates success, because an <code class="inline">'a'</code> was discovered as the first character. If we were unsuccessful, just like in <code class="inline">anychar</code>, instead of <code class="inline">('a', 'bc')</code>, we'd have seen <code class="inline">None</code> returned.</p>

<p>It is a bit verbose to always create a <code class="inline">lambda</code> to match a single character, so <code class="inline">matchchr</code> gets a target character and calls <code class="inline">chartest</code> for us. (Remember, calling <code class="inline">chartest</code> creates a <em>new</em> parser function, this is an important thing to note.)</p>

<pre><code>def matchchr(targetchr):
    return chartest(lambda x: x == targetchr)
</code></pre>

<p>Now we can match single characters against our input stream, which is a great starting point, but hardly makes for an easy to use library. One limitation is that there is no way to specify more than one character as a possible match, such as "all alpha numeric"&mdash;for that, we use <code class="inline">oneof</code>.</p>

<pre><code>def oneof(target):
    chars = set([x for x in target])
    return chartest(lambda x: x in chars)
</code></pre>

<p><code class="inline">oneof</code> creates a new test function to pass to chartest, which instead of testing if a character is equal to a single target character, checks to see if the character is in the set of characters we're looking for. Some useful definitions follow, which make parser functions using <code class="inline">oneof</code>, and a set of characters.</p>

<pre><code>alpha = oneof('abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ')
loweralpha = oneof('abcdefghijklmnopqrstuvwxyz')
upperalpha = oneof('ABCDEFGHIJKLMNOPQRSTUVWXYZ')
digit = oneof('0123456789')
hexdigit = oneof('0123456789abcdefABCDEF')
whitespace = oneof(' \t\n\r')
</code></pre>

<p>While matching a single character is useful, it would be much more useful if we could match a <em>token</em>, like "<code class="inline">while</code>," or "Content-Type." Not to worry, <code class="inline">matchstr</code> produces a parser function that will combine the previously created <code class="inline">matchchr</code> for each character in the target string. It looks a bit complicated, so we'll go through it step by step.</p>

<pre><code>def matchstr(target):
    if not target:
        return lambda strn: ("", strn)

    def _(strn):
        c = matchchr(target[0])(strn)
        if c:
            cs = matchstr(target[1:])(c[1])
            if cs:
                return (c[0] + cs[0], cs[1])
        return None
    return _
</code></pre>

<p><code class="inline">target</code>, just like <code class="inline">targetchr</code> in <code class="inline">matchchr</code> is the string we're eventually trying to match in full. If <code class="inline">target</code> is empty, then our parser function is simple&mdash;it doesn't advance the input string, and doesn't consume anything.</p>

<p>Why don't we return <code class="inline">None</code> here? Well, if our target is empty, we're not asking <code class="inline">matchstr</code> to do any work at all, so there isn't a failure (indicated by <code class="inline">None</code>). It, however, also makes for a great base case to the recursion that follows.</p>

<p>If there <em>is</em> a target string to match against, we attempt to match the first character within it. If that succeeds, we shorten the target string and recurse. We eventually return a combination of the result of <code class="inline">matchchr</code> and the result of the recursive call to <code class="inline">matchstr</code>. Take a minute to look over this and ensure you understand it&mdash;it's actually pretty straightforward assuming understanding of the previous functions.</p>

<p>Let's take a look at how we use it:</p>

<pre><code>&gt;&gt;&gt; matchwhile = matchstr('while')
&gt;&gt;&gt; matchwhile('while True:')
('while', ' True:')
</code></pre>

<p>As you can see, we used <code class="inline">matchstr</code> to <em>build</em> a parser function which matches the string "<code class="inline">while</code>"&mdash;simple enough.</p>

<p>Ok, so what if we want to parse more complicated things, like say, the rest of the input string from the "while True:" example? We need some ways to combine these parser functions to make them more useful, otherwise, all we did was create the equivalent of:</p>

<pre><code>if strn.startswith("while"):
    return (strn[0:5], strn[5:])
</code></pre>

<p>Which, in Python, would be much more efficient!<sup><a id="return-efficiency" href="#note-efficiency">[4]</a></sup>

<p>Another parser function that we need to make this whole thing useful is <code class="inline">optional</code>. <code class="inline">optional</code> takes as an argument a parser function, and returns a new parser function that succeeds even if the original parser function does not. Essentially, if there is a failure, it returns the original input string.</p>

<pre><code>def optional(parserfn):
    def _(strn):
        c = parserfn(strn)
        if c:
            return c
        return ('', strn)
    return _
</code></pre>

<p>If we make <code class="inline">matchwhile</code>, from above, optional we get this:</p>

<pre><code>&gt;&gt;&gt; optional_matchwhile = optional(matchwhile)
&gt;&gt;&gt; optional_matchwhile('foo')
('', 'foo')
</code></pre>

<p>Without <code class="inline">optional</code>, attempting to call <code class="inline">matchwhile</code> on the input string <code class="inline">'foo'</code> would have resulted in <code class="inline">None</code>, the failure condition.</p>

<p>The presence of <code class="inline">optional</code> also leads us to <code class="inline">repeat</code> and <code class="inline">repeat0</code> which are mutually exclusive. <code class="inline">repeat</code> will attempt to match the parser function at least once, with no boundary. <code class="inline">repeat0</code> will match the parser function zero or more times:</p>

<pre><code>def repeat(parser):
    def _(strn):
        c = parser(strn)
        if c:
            cs = repeat0(parser)(c[1])
            return (c[0] + cs[0], cs[1])
        return None
    return _

def repeat0(parser):
    return optional(repeat(parser))
</pre></code>

<p>Again, like <code class="inline">optional</code>, <code class="inline">repeat</code> and <code class="inline">repeat0</code> build parser functions from existing ones. This is very much a common pattern when building parsers of this type.</p>

<p>The implementation of <code class="inline">repeat0</code> and <code class="inline">repeat</code> is quite clever. Note that zero or more is the same as <em>optionally</em> one or more. The implementation of both follows from that realization. <code class="inline">repeat</code> first attempts to call the passed in parser function. If it succeeds it calls <code class="inline">repeat0</code> on the rest of the input string after calling <code class="inline">parser</code> the first time. If <code class="inline">repeat0</code> succeeds, which it always will given <code class="inline">optional</code>, we combine the results and return.

<pre><code>&gt;&gt;&gt; optrepeat_while = repeat0(matchwhile)
&gt;&gt;&gt; optrepeat_while('whilewhilewhile')
('whilewhilewhile', '')
&gt;&gt;&gt; optrepeat_while('foo')
('', 'foo')
&gt;&gt;&gt; repeat_while = repeat(matchwhile)
&gt;&gt;&gt; repeat_while('foo')
None
&gt;&gt;&gt; repeat_while('while foo')
('while', ' foo')
</code></pre>

<p>We still need the ability to do alternation, like "while" <em>or</em> "if." For that we introduce <code class="inline">alt</code>.</p>

<pre><code>def alt(*parsers):
   def _(strn):
       for p in parsers:
           result = p(strn)
           if result:
               return result
   return _
</code></pre>

<p>This is really simple. We take a list of parser functions and try them one by one, from left to right, until we find one that passes.</p>

<pre><code>&gt;&gt;&gt; iforwhileorfor = alt(matchstr('if'), matchstr('while'), matchstr('for'))
&gt;&gt;&gt; if_while_for('if')
('if', '')
&gt;&gt;&gt; if_while_for('while')
('while', '')
&gt;&gt;&gt; if_while_for('for')
('for', '')
&gt;&gt;&gt; if_while_for('foof')
None
</code></pre>

<p>Alternation is important, but it is maybe even <em>more</em> important to ensure that many parser functions pass in order, a sequence of parser functions if you will. It is this operator that allows us to do something like <code class="inline">whilestmt = sequence(whileToken, conditional, colonToken, codeBlock)</code>.</p>

<pre><code>def sequence(*parsers):
    def _(strn):
        parsed = ''
        rest = strn
        for p in parsers:
            result = p(rest)
            if result:
                rest = result[1]
                parsed += result[0]
            else:
                return None
        return (parsed, rest)
    return _
</code></pre>

<p>Assuming simplified definitions of the supporting rules, our <code class="inline">whileStmt</code> example looks something like this:</p>

<pre><code>&gt;&gt;&gt; whileToken = matchstr("while")
&gt;&gt;&gt; conditional = oneof("&gt;&lt;=")
&gt;&gt;&gt; colonToken = matchchr(":")
&gt;&gt;&gt; codeBlock = alt(matchstr("if"), matchstr("for"))
&gt;&gt;&gt; whileStmt = all(whileToken, conditional, colonToken, codeBlock)
&gt;&gt;&gt; whileStmt('while&lt;:if')
('while&lt;:if', '')
&gt;&gt;&gt; whileStmt('while&gt;:if')
('while&gt;:if', '')
&gt;&gt;&gt; whileStmt('while>:for')
('while&gt;:for', '')
&gt;&gt;&gt; whileStmt('while:for')
None
</code></pre>

<p><code class="inline">sequence</code> looks complicated, but is rather simple. It is basically <code class="inline">reduce</code>, combining the results of each parser into the results of all of the parser function outputs together.</p>

<p>That's all we really need to construct more interesting parsers, so we'll now construct a simplified parser for JSON.<sup><a id="return-json" href="#note-json">[5]</a></sup></p>

<p>We'll start with some utility functions:</p>

<pre><code>def betweenchrs(parser, left="(", right=")"):
    def _(strn):
        lres = matchchr(left)(strn)
        if lres:
            pres = parser(lres[1])
            if pres:
                rres = matchchr(right)(pres[1])
                if rres:
                    return (left + pres[0] + right, rres[1])
        return None
    return _

betweenparens = lambda p: betweenchrs(p, left="(", right=")")
betweenbrackets = lambda p: betweenchrs(p, left="[", right="]")
betweencurlies = lambda p: betweenchrs(p, left="{", right="}")
</code></pre>

<p><code class="inline">betweenchrs</code> lets us easily create a parser function which attempts to parse, using <code class="inline">parser</code>, only if it is between <code class="inline">left</code> and <code class="inline">right</code>. This is useful in JSON, because of its list and dictionary data types, which are delimited by <code class="inline">[]</code> and <code class="inline">{}</code> respectively.</p>

<p>Strings in JSON are composed of a series of characters between <code class="inline">"</code>'s. But, if you want to actually use a <code class="inline">"</code> within the string, you can do that by preceding it with a <code class="inline">\</code>. We can make a parser function that satisfies these rules rather easily, making use of <code class="inline">anychar</code>.</p>

<pre><code>def charorquoted(strn):
    c = anychar(strn)
    if c[0] == '"':
        return None
    elif c[0] == '\\':
        c2 = chartest(lambda x: x in ('\\', '"'))(c[1])
        if c2:
            return (c[0] + c2[0], c2[1])
    else:
        return c
</code></pre>

<p>In the case that we find a '"' character without a '\' character preceding it, it is a failure.</p>

<p>Whitespace doesn't much matter between tokens in JSON, so let us define something that ultimately ignores it. <code class="inline">ignorews</code> uses <code class="inline">repeat0</code> to strip the preceding whitespace, calls the parser function given using the left over input string. If the parser function passes, it calls <code class="inline">repeat0</code> again against whitespace and ultimately returns the passed in parser function's parsed result and the ignored whitespace's left over input string. That's a mouthful, but it's fairly easy to understand:</p>

<pre><code>def ignorews(p):
    def _(strn):
        w = repeat0(whitespace)(strn)
        if w:
            pres = p(w[1])
            if pres:
                w2 = repeat0(whitespace)(pres[1])
                if w2:
                    return (pres[0], w2[1])
        return None
    return _
</code></pre>

<p><code class="inline">anint</code>, <code class="inline">astring</code>, <code class="inline">acolon</code> and <code class="inline">acomma</code> are just helper functions which do exactly what they describe. We're simplifying this implementation, as it is for demonstration purposes, so we're not taking into consideration floating point numbers, or integers specified using hexidecimal and other formulations of numbers.</p>

<pre><code>anint = sequence(optional(matchchr("-")), repeat(digit))
astring = betweenchrs(repeat0(charorquoted), left='"', right='"')
acolon = matchchr(':')
acomma = matchchr(',')
</code></pre>

<p>When we define dictionaries and lists, we run into a problem. Both lists and dictionaries can contain lists and dictionaries (as well as numbers and strings of course), which represents a problem for when we define these functions (we can't recursively define something that doesn't already exist!). One solution to this problem is to use a mutable object which acts as a "forward reference." When we finish defining the pieces we need, we update the forward reference, and then all is well.</p>

<p>For both aesthetic, and practical reasons, we'll use a class instance which overrides <code class="inline">__call__</code>, and  <code class="inline">__ilshift__</code>, which will allow us to use an instance of <code class="inline">Forward</code> as a parser function, and <code class="inline">&lt;&lt;=</code> (from __ilshift__) as a way to update the parser function that's contained within the reference.</p>

<pre><code>class Forward(object):
    def __init__(self):
        self.p = None

    def __call__(self, *args, **kwargs):
        return self.p(*args, **kwargs)

    def __ilshift__(self, p):
        self.p = p
        return self
</code></pre>

<p>To use a <code class="inline">Forward</code>, we simply create an instance of <code class="inline">Forward</code> and assign it to a variable, just as if we were creating a parser function. <code class="inline">Forward</code> is like a promise. "If you act like a parser function for me for a little bit, I promise I'll actually turn you into one later." If the promise is kept, and the <code class="inline">Forward</code> is updated, parsing will proceed as if nothing was ever not specified to begin with.</p>

<pre><code>avalue = Forward()
akey = ignorews(alt(anint, astring))
akeyvaluepair = sequence(akey, acolon, avalue)
</code></pre>

<p>Both lists and dictionaries have items that are separated by comma. <code class="inline">commaseparated</code> is essentially <code class="inline">repeat0</code> except that it ensures a comma appears after each item, except in the last item.

<pre><code>def commaseparated(parser):
    def _(strn):
        r = repeat0(sequence(parser, acomma))(strn)
        if r:
            r2 = parser(r[1])
            if r2:
                return (r[0] + r2[0], r2[1])
        elif r:
            return r
        return None
    return _
</code></pre>

<p>Now that we have all the pieces specified, we put a <code class="inline">commaseparated</code> key value pair between curly braces to parse a dictionary, and a <code class="inline">commaseparated</code> value parser function between square brackets to parse a list.</p>

<pre><code>adict = betweencurlies(commaseparated(akeyvaluepair))
alist = betweenbrackets(commaseparated(avalue))
</code></pre>

<p>We still have our promise to keep for <code class="inline">avalue</code>, and with the definitions of <code class="inline">alist</code> and <code class="inline">adict</code>, we now can. <code class="inline">avalue</code>, as in JSON, should either be a number, a string, a list or a dictionary, and whitespace is ignored.</p>

<pre><code>avalue <<= alt(*map(ignorews, [adict, alist, anint, astring]))
</code></pre>

<p>To achieve alternation, we make use of <code class="inline">alt</code>, but before we do that, we wrap each parser function contained in <code class="inline">avalue</code> in an <code class="inline">ignorews</code> parser function builder to satisify that requirement. Finally, we shift the newly created parser function into the forward reference for <code class="inline">avalue</code>.</p>

<p>To parse a top level JSON document, we look for either a list, or a dictionary. The parser function to do that is quite easy to specify.</p>

<pre><code>json = alt(adict, alist)
</code></pre>

<p>Last, but certainly not least, let's actually use what we've constructed:</p>

<pre><code>&gt;&gt;&gt; json('''{"hello": {1: "how are you?"}, "i is": "fine", "how": "are you?", 1: ["these", "values", "work", 2]}''')
('{"hello":{1:"how are you?"},"i is":"fine","how":"are you?",1:["these","values","work",2]}', '')
</code></pre>

<p>Success!</p>

<p>While we haven't shown how to formulate an LL(k) grammar, or even talked about what that actually is formally, we have shown that with a few simple functions that build parser functions, we can build, quite easily, parsing functions which parse complicated things. However, we've only shown that the input is valid, actually constructing a parse tree, or acting upon it, is left as an exercise to the reader.</p>

<p>Source code for all this is <a href="http://files.sigusr2.net/parser_functions.py">here</a>

<ol class="footnotes">
   <li id="note-solvedproblem">I'm not sure if parsing is really "solved," but the algorithms we have work well enough in practice that there isn't a ton of interesting new research going on around it. <a href="http://arxiv.org/abs/1010.5023">Yacc is Dead</a>, for instance used the results of <a href="http://portal.acm.org/citation.cfm?id=321249">a paper</a> from 1964, but came <a href="http://research.swtch.com/2010/12/yacc-is-not-dead.html">under fire</a>. Can parsing be made trivially easy? Maybe, but it's likely that ambiguity will be somewhere&mdash;which would be the unsolved in parsing.<a href="#return-solvedproblem">&crarr;</a></li>
   <li id="note-leftrecursion">See <a href="#note-leftrecursion">left</a> <a href="http://en.wikipedia.org/wiki/Left_recursion">recursion</a>. All joking aside, left recursion occurs in a grammar when a non-terminal rule is used recursively and appears on the left. For example: <code class="inline">expr = expr + tail</code>. <a href="#return-leftrecursion">&crarr;</a></li>
   <li id="note-hutton1989">Graham Hutton. Proceedings of the 1989 Glasgow Workshop on Functional Programming (Fraserburgh, Scotland), Springer-Verlag Series of Workshops in Computing, Springer-Verlag, Berlin, 1990.<a href="#return-hutton1989">&crarr;</a></li>
   <li id="note-efficiency">The purpose of this article isn't to describe an efficient parsing technique for Python, but to rather demonstrate a useful technique that could be adapted and built upon, to build an efficient parsing framework for <em>any</em> language that supports first class functions. There's a follow up article to this which shows just how much of this can actually be abstracted out in order to make it even more simple.<a href="#return-efficiency">&crarr;</a></li>
   <li id="note-json">We limit our parser to strings, integers, dictionary and lists. The complete specification appears at <a href="http://json.org">http://json.org</a><a href="#return-json">&crarr;</a></li>
</ol>
]]></content></entry>
<entry><title>Code Blogging: ARGF in Python</title><link href="http://sigusr2.net/2010/Jun/23/argf.html"/><id>md5:9d5ba6e7df3fe6f44b607a6a0be06952</id><updated>2010-06-23T00:00:00Z</updated><content type="html"><![CDATA[<pre><code class="python">"""ARGF from Ruby in Python.
Released into the public domain by Andrew Gwozdziewycz, 2010
"""

import sys, os


class _ARGF(object):

    def __init__(self):
        self.lineno = 0
        self.file = None

    def __iter__(self):
        return self.next()

    def next(self):
        files = filter(os.path.isfile, sys.argv[1:])
        pairs = [(f, open(f)) for f in files] \
            if files else [('STDIN', sys.stdin)]
            
        for name, fobj in pairs:
            self.file = name

            for line in fobj.xreadlines():
                self.file = 'STDIN'
                self.lineno += 1
                yield line

ARGF = _ARGF()
</code></pre>

<p><strong>Update:</strong> It was pointed out that I didn't handle <code class="inline">lineno</code> correctly; I fixed it.</p>
]]></content></entry>
<entry><title>Maps are Broken, for Some Definition of Broken</title><link href="http://sigusr2.net/2010/Jun/22/maps-are-broken-for-some-definition-of-broken.html"/><id>md5:ee8c78a17c21d8d986ea5f7e3bc78811</id><updated>2010-06-22T00:00:00Z</updated><content type="html"><![CDATA[<p><span class="preamble">Map datatypes are extremely useful for a variety of tasks in programming. But, they are often painful to use; take for example the following task.</span></p>

<p>In Java, I have a <a href="http://java.sun.com/j2se/1.5.0/docs/api/java/util/HashMap.html">HashMap</a> and I wish to get a random key. Well, <a href="http://java.sun.com/j2se/1.5.0/docs/api/java/util/AbstractMap.html">AbstractMap</a> doesn't define a way to get a random key, but it does provide a way to get a <a href="http://java.sun.com/j2se/1.5.0/docs/api/java/util/Set.html">Set</a> of keys. Does Set have a way to get a random element? No, but you can create an Array from a Set with the <code class="inline">toArray()</code> method on Set.</p>

<p>We end up with the following:</p>

<pre><code>public String randomKey() {
    // Assuming: map = HashMap&lt;String, String&gt;;
    Set&lt;String&gt; set = map.keySet();
    Object[] strings = set.toArray();
    Random random = new Random();
    if (strings.length &gt; 0) {
        return (String)strings[random.nextInt(strings.length)];
    }
    return null;
}
</code></pre>

<p>Now, this isn't necessarily bad, but we have to create a new array, and a new set each time we want a random key. We can of course be smarter about this by caching the array and/or set, but then we run into synchronization issues. We also get screwed when we attempt to implement the <code class="inline">popRandom()</code> operation, which could be implemented like so:</p>

<pre><code>public String popRandom() {
    String key = randomKey();
    if (key != null) {
        String value = map.get(key);
        map.remove(key);
        return value;
    }
    return null; // or more appropriately, throw an exception
}
</code></pre>

<p>So, we're doing all this extra copying, allocating and deleting, when all we really need is an iterator, to solve this generically in <code class="inline">O(n)</code> time.</p>

<pre><code>public String randomKey() {
    // randomKey method in O(n) using imaginary iterator() on AbstractMap
    int size = map.size();
    if (size &gt; 0) {
        int index = new Random().randInt(size);
        Iterator&lt;String&gt; keys = map.iterator();
        while (keys.hasNext()) {
           if (index-- == 0) {
               return keys.next();
           }
           keys.next();
        }
    }
    return null;
}
</code></pre>


<p>This sort of thing isn't necessarily true for dynamic languages like Python which normally have ways to iterate over keys in a map, dictionary or set. They still don't have a way to get a random element from either out of the box without resulting to the <code class="inline">O(n)</code> iteration method, or converting to a list and using a random index approach.</p>

<pre><code>&gt;&gt;&gt; import random
&gt;&gt;&gt; random.choice(set([1, 2, 3]))
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
  File "/System/Library/Frameworks/Python.framework/Versions/2.5/lib/python2.5/random.py", line 248, in choice
    return seq[int(self.random() * len(seq))]  # raises IndexError if seq is empty
TypeError: 'set' object is unindexable
</code></pre>

<pre><code>&gt;&gt;&gt; random.choice({'1': 'world', '2': 'galaxy', '3': 'universe'})
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
  File "/System/Library/Frameworks/Python.framework/Versions/2.5/lib/python2.5/random.py", line 248, in choice
    return seq[int(self.random() * len(seq))]  # raises IndexError if seq is empty
KeyError: 2
</code></pre>

<p>And of course that makes sense given how <code class="inline">random.choice</code> is implemented, since there's not necessarily  an order for the elements of a set or dictionary, so you can't expect to subscript them. However they do provide an order when iterating over them and traversing the structure they exist in, so you could certainly use the same <code class="inline">O(n)</code> approach from above.</p>

<p>If there's some other less obvious way to do this in Java using a <a href="http://en.wikipedia.org/w/index.php?title=Dependency_injection&oldid=260831402#A_code_illustration_using_Java">EnterpriseFactoryObserverFactoryFactoryCreator</a>, please leave a comment.</p>


<p><strong>Update: I overlooked something important, which was pointed out by <a href="http://news.ycombinator.com/item?id=1452619">gojomo</a> on Hacker News. Set, which is returned from <code class="inline">keySet()</code> on HashMap, has an iterator. Thus:</strong></p>

<pre><code>public String randomKey() {
    int index = random.nextInt(map.size());
    for (String key: map.keySet()) {
        if (index-- == 0) {
            return key;
        }
    }
    return null;
}
</code></pre>
]]></content></entry>
<entry><title>Pattern Matching with "With"</title><link href="http://sigusr2.net/2010/Apr/28/pattern-matching-with-with.html"/><id>md5:862f9d6d39aec112eecc179210926c60</id><updated>2010-04-28T06:29:00Z</updated><content type="html"><![CDATA[<p>
<span class="preamble">When I originally thought about adding pattern matching to Python, in the <a href="http://sigusr2.net/2008/Sep/30/python-type-constructors-like-ocaml.html">OCaml sense</a>, I ended up using a decorator that more or less registed a bunch of callbacks with a dispatch table based on the types of it's arguments.</span>
</p>

<p>That worked out fine, but it didn't really have the feel of <a href="http://en.wikipedia.org/wiki/Pattern_matching">pattern matching</a> like you get with real <a href="http://en.wikipedia.org/wiki/Algebraic_data_type">algebraic data types</a>. If you recall, I was playing with the following example with the decorator approach:
</p>

<pre><code class="ocaml">type astnode = 
| AndNode of astnode * astnode
| OrNode of astnode * astnode
| NotNode of astnode 
| IdNode of bool

let rec eval_node (n: astnode) = 
  match n with
  | AndNode (l, r) -> (eval_node l) && (eval_node r)
  | OrNode (l, r) -> (eval_node l) || (eval_node r)
  | NotNode l -> not (eval_node l)
  | IdNode v -> v

eval_node (AndNode (IdNode true, IdNode false)) (* returns false *)
</code></pre>

<p>The idea of that program was to create a small language to evaluate boolean expressions. In OCaml, it's quite succinct&mdash;too succinct, in all honesty. That's it. Of course it doesn't include a parser, or a lexer, but that's the crux of it.
</p>

<p>Since that original post, I've posted about two other <q>language hacks</q> that I've attempted to create&mdash;both of which use <a href="http://www.python.org/dev/peps/pep-0343/">context managers</a> and the <code class="inline">with</code>-statement, <a href="http://sigusr2.net/2009/Oct/01/python-worlds.html">worlds</a> and <a href="http://sigusr2.net/2009/Mar/04/dispatching-with-with.html">dispatching urls (a la routes)</a>.</p>

<p>Basically, it occurred to me yesterday, that <code class="inline">with</code>'s <code class="inline">as</code> clause did destructuring of tuples, in the same way that the assignment statement does. That is to say:</p>

<pre><code class="python">a, b, c = 1, 2, 3</code></pre>

<p>Will correctly assign <code class="inline">a = 1</code>, <code class="inline">b = 2</code>, <code class="inline">c = 3</code>, in the same exact way that:</p>

<pre><code class="python">from contextlib import contextmanager
@contextmanager
def assign(*args):
    yield args

with assign(1, 2, 3) as (a, b, c,):
    pass
</code></pre>

<p>will assign <code class="inline">a = 1</code>, <code class="inline">b = 2</code>, <code class="inline">c = 3</code>.</p>

<p>I'll admit, that doesn't look very powerful by itself, but when you consider the possibilities, you might come up with something like I did:</p>

<pre><code class="python">with structural_matching((1, 2, 3)) as match:
    with match('list() x y z') as (x, y, z):
        print x, y, z
    with match('tuple() x _ z') as (x, z):
        print "tuple case"
        print x, z
</code></pre>

<p>which looks incredibly close to pattern matching in OCaml. I was super excited&mdash;but it won't work.</p>

<p>See, <code class="inline">match</code> is a context manager that gets returned with the intention that if the <code class="inline">__enter__()</code> method raises a <code class="inline">NoMatch</code> exception, it skips the "body" and goes to the next match. The problem with that thinking however is simple&mdash;there's no way for <code class="inline">__enter__</code> to force skipping the body due to rejected <a href="http://www.python.org/dev/peps/pep-0377/">PEP-377</a>!</p>

<p>In the example above (full source <a href="http://files.sigusr2.net/match1.py">here</a>), raising <code class="inline">NoMatch</code> in the first <code class="inline">match</code> block, results in control being passed back to the <code class="inline">__exit__()</code> of the outer context manager&mdash;<code class="inline">structural_matching</code>. And to think, I got my hopes up!</p>

<p>But nevertheless, I pressed on, and hacked <a href="http://files.sigusr2.net/match2.py">together</a>, a <code class="inline">match</code>, that can destructure the following examples correctly:</p>

<pre><code class="python">with match('[1:3]', [1, 2, 3, 4]) as (a,):
    print a
# [2, 3]

with match('[1:]', "hello world") as (a,):
    print a
# ('e', 'ello world')

with match('str() x y', 'hello world') as (h, e):
    print 'h = ', h, ',',
    print 'e = ', e
# h = h, e = e

with match('x y z', [1, 2, 3]) as (x, y, z,):
    print z, y, x
# 3 2 1

class obj(object):
    def __init__(self, x, y):
        self.x = x
        self.y = y

with match('obj() .x .y', obj('x-ity', 'y-ity')) as (x, y):
    print 'x = ', x, ',',
    print 'y = ', y
# x = x-ity, y = y-ity

with match('x y _', [1, 2, 3]) as (x, y):
    print x, y
# 1, 2
</code></pre>

<p>It's much less useful considering you can't put it in the <code class="inline">structural_match</code> block ,like you would in a <em>real</em> <code class="inline">match</code> statement, but it's all we've got.</p>

<p>Back then, I concluded with <q>This is as close to OCaml like  pattern matching that we're going to get, at least as far as I know how to get, but it's sort of cool, and definitely a hack.</q> Today, I'll conclude the same way.</p>
]]></content></entry>
<entry><title>Remote Objects</title><link href="http://sigusr2.net/2009/Nov/20/remote-objects.html"/><id>md5:c613f9f24fe2f9428acc9780d5c39573</id><updated>2009-11-20T00:00:00Z</updated><content type="html"><![CDATA[<p><span class="preamble">Back in May, I was tasked with migrating a few years worth of <a href="http://roundup.sourceforge.net/">Roundup</a> data to <a href="http://www.activecollab.com/">activeCollab</a>&mdash;a more featured project management and collaboration tool.</span></p>

<p>The move was justified, as Roundup no longer matched the way our organization wished to conduct business. It was a good move, but as with any migration there are bound to be some hiccups along the way.</p>

<p>Right away I hit one. The data models for these 2 very different pieces of software are insanely different (who knew?). Roundup makes <em>use of</em> a <a href="http://en.wikipedia.org/wiki/SQL">SQL</a> database, but not in a traditional way. And, activeCollab combines almost all of its entities into one table. This of course makes querying with SQL incredibly difficult, and a SQL to SQL translation close to impossible.</p>

<p>Luckily, in moving to activeCollab, we inherited a somewhat <a href="http://en.wikipedia.org/wiki/Representational_State_Transfer">RESTful</a>, API that allows for the modification and creation of entities. As a result, it became apparent that the logical way to migrate this was to pull the data out using the Roundup's libraries and make the appropriate API calls with the translated data.</p>

<p>To make it easy on myself, I developed a quick <a href="http://en.wikipedia.org/wiki/Object_relational_mapper">ORM</a>-like interface to the APIs. I had the idea that if I could make it work for activeCollab, it must be generalizable enough to work for other services and APIs as well, which I could do later.</p>

<p>And, I was right. It could be more generalized, and it could be useful. In fact, the idea was so useful that 3,000 miles away in the San Francisco office someone else was already secretly working on the same idea!</p>

<h3>Enter Remote Objects</h3>

<p>The result of the secretive effort, that I became aware of, is called <a href="http://github.com/sixapart/remoteobjects/">Remote Objects</a>, which identifies itself as <q>An object RESTational model.</q> <a href="http://sixapart.com/">Six Apart</a> has graciously released it as part of the requirements to run <a href="http://www.typepad.com/go/motion">TypePad Motion</a>, which is also available, under a <a href="http://en.wikipedia.org/wiki/BSD_License">BSD License</a>, on <a href="http://github.com/sixapart/typepad-motion">github</a>.</p>

<p>But, just because its main intentions were for being used against the <a href="http://developer.typepad.com/api/rest.html">TypePad APIs</a>, doesn't mean that it <em>only</em> works with them.</p>

<p>In fact, the developers had the foresight to think that this would be useful in other cases too, just as I did, as can be seen in the <a href="http://github.com/sixapart/remoteobjects/tree/master/examples">examples</a> that come with the package.</p>

<p>Needless to say, I abandoned my implementation of this idea and will adopt Remote Objects in the future. Have a look. Hopefully it is useful in your toolbox too.</p>
]]></content></entry>
<entry><title>Python Worlds</title><link href="http://sigusr2.net/2009/Oct/01/python-worlds.html"/><id>md5:8ec25d2f452904fcb32829303656bf92</id><updated>2009-10-01T00:00:00Z</updated><content type="html"><![CDATA[<p><span class="preamble">Last year, I was introduced to a paper via <a href="http://lambda-the-ultimate.org/node/3040">Lambda the Ultimate</a> about <q>worlds,</q> a language construct which allows one to control the scope of side effects while programming.</span></p>

<p>Worlds allow you to capture the current scope of a program in a first-class way. All updates to the current state (i.e. local variables, global variables) happen in a non-commiting way. In other words, you can back out of any changes at any time.</p>

<p>Consider the following example (taken from the <a href="http://www.vpri.org/pdf/rn2008001_worlds.pdf">Warth paper</a>):</p>

<pre><code class="javascript">A = thisWorld; // thisWorld is always the current world
r = new Rectangle(4, 6);

B = A.sprout(); // sprout creates a new world with it's parent set to A
in B { r.h = 3; } // side effects within this `in' occur only in the world B.

C = A.sprout();
in C { r.h = 7 }; // in A's world r.h = 6 still.

C.commit(); // only now does r.h = 7 in world A.
</code></pre>

<p>If you follow along in the comments I've appended to the example, you'll start to see why this idea is interesting, even from this little example.</p>

<p>The astute Scheme programmer, however, will notice almost certainly that this construct could be created with <code class="inline">call/cc</code>, which is certainly true. The problem with this fact is that not all programming languages are Scheme (unfortunately), and of course not all languages support first-class <a href="http://en.wikipedia.org/wiki/Continuation">continuations</a>.</p>

<p>The question I asked myself, however, is this: <q>Can I hack worlds into Python?</q> To which I came up with the short answer after some thinking, <q>sort of.</q>

<p>I guess I should explain what's going on more clearly in the example above. The first thing to note is that <code class="inline">A</code> represents the current scope; the current state of all variables in the program. <q>Sprouting</q> a new world from an existing world means that any changes that occur when using the sprouted world, do not affect the world who sprouted the current world, unless the new world <em>commits</em> the changes made to the original world.</p>

<p>Which is to say, changes that occur in an <code class="inline">in</code> block acting on world <code class="inline">X</code> do not propagate to the parent (the world <code class="inline">X</code> was sprouted from) of <code class="inline">X</code> unless <code class="inline">X.commit()</code> is called.</p>

<h3>Enter Context Managers</h3>

<p>A few months ago, I wrote a blog post about <em><a href="http://sigusr2.net/2009/Mar/04/dispatching-with-with.html">Dispatching With "with"</a></em>, in which I explained <a href="http://www.python.org/dev/peps/pep-0343/">context managers</a> in Python, and how they can be exploited to create a less separated mapping from URLs to request handlers (something that definitely has its place in the small web-app world).</p>

<p>The basic idea of this was that in the <code class="inline">__exit__</code> method of the web-application object, the current frame was inspected and references to functions that represent HTTP methods would be collected, stored and tied to the last regular expression passed to the <code class="inline">expose</code> method in the application object. This simple solution allowed us to express a web application succinctly like so:

<pre><code class="python">app = web.application()
with app.expose('/'):
   def get(): 
       return "Hello World"
app.run()
</code></pre>

<p>For worlds, I also exploit context managers, though mostly for the <code class="inline">in</code>-like syntax, and for managing the current <code class="inline">thisWorld</code> variable.</p>

<p>The quick<a href="#f1">[1]</a> solution that I came up with for <a href="http://github.com/apgwoz/python-worlds">implementing worlds</a> can be used like so:</p>

<pre><code class="python">with Universe(): # establishes new world, assigns to local variable `thisWorld'
   thisWorld.r = True # must assign <em>directly</em> in the world. LIMITATION
   new = thisWorld.sprout() 

   with new:
       new.r = False

   with new.sprout():
       thisWorld.r = 15
       thisWorld.commit() # now new.r is 15, but the original r is still True

   print thisWorld.r # => True
   new.commit()
   print thisWorld.r # => 15
   thisWorld.commit() # have to commit to the actual scope LIMITATION
   # r is now part of the local variables where this universe exists
   print r # => 15 
</code></pre>

<p>Looking at this example, it's already apparent that the Warth implementation of worlds is superior, just in the amount of code needed to take advantage of it. You might also see that I didn't even attempt to port the rectangle example  from above. That is because there isn't anything smart going on under the hood when it comes to container objects (such as lists, tuples, objects, dicts), and I'm not yet sure how to get there.</p>

<p>With simple immutable objects such as booleans, integers and strings, using copy-on-write semantics works wonderfully. Then, on <code class="inline">commit</code> of the world, the code just copies all of the changes into its parent. I haven't tackled the case of mutable container objects just yet, as there are complications in the API<a href="#f2">[2]</a>, as well as the implementation.</p>

<p>The interaction with this is sort of annoying though. In order to take advantage of worlds in Python, you have to touch virtually every line of code in the function you are trying to <q>worldize</q>, because you must assign explicitly to a world. The world's context manager sets up <code class="inline">thisWorld</code> for you, but you still have to do <code class="inline">thisWorld.<em>variable</em></code> to get any sort of benefit.</p>

<p>My inclination is to get into some bytecode hacking to modify all assignments within the <code class="inline">with</code> block to be assignments to <code class="inline">thisWorld</code> automatically, but bytecode hacks are neither pleasant to maintain, nor are they portable across implementations.</p>

<p>It's also possible in the Warth version to <q>worldize</q> functions and any other first class object. Maybe the solution is simple and I just haven't seen it yet. Whatever hacks, that I come up with though, will be just that, hacks, as there is no <em>easy</em> way to add worlds to Python in the same way that Warth added them to JavaScript<a href="#f3">[3]</a>.</p>

<p>We are in an age of programming where mainstream programming languages are unable to adapt to our needs as programmers. We are unable to bend them at our will like we can with <a href="http://en.wikipedia.org/wiki/Scheme_%28programming_language%29">Scheme</a>, <a href="http://common-lisp.net/">Lisp</a> and even <a href="http://clojure.org/">Clojure</a>. Attempts to bring about change on this front have not been met with enthusiasm from most groups. Whether it's a lack of marketing, evangelism or just that the general population doesn't view <q>unbendability</q> as a problem, I'm not sure. But, I for one like the idea of being able to <em>easily</em> add worlds, and other ideas, as <em>true</em> language features to languages that by practicality, I'm forced into using. That would make me a much happier, and effective programmer.</p>

<ol class="footnotes">
    <li id="f1">By quick, I do mean quick. This was 2 hours of work and sketching. Surely there is lots of work to be done to make it a true solution.</li>
    <li id="f2">The same strategy could be used as for simple values like booleans, if the API used a method, say <code class="inline">assign</code> instead of the more natural assignment operator. Consider, <code class="inline">thisWorld.assign('obj.height.inches', 30)</code> vs. <code class="inline">thisWorld.obj.height.inches = 30</code>.</li>
    <li id="f3">The Worlds prototype was written in <a href="http://tinlizzie.org/ometa/">OMeta</a>, which is a solution to the "unbendable" languages problem. Note: I didn't attempt to write worlds in PyMeta, but, it may be possible to do.</li>
</ol>
]]></content></entry>
<entry><title>Bitten... Really Hard</title><link href="http://sigusr2.net/2009/Sep/09/bitten-really-hard.html"/><id>md5:56c6a1146108e40e674d0df15cd6c5b2</id><updated>2009-09-09T00:00:00Z</updated><content type="html"><![CDATA[<p><span class="preamble">Last Friday I was bitten really hard by something I would not have, in my wildest dreams think would bite me, Python's <a href="http://docs.python.org/library/urllib2.html"><code class="inline">urllib2</a></code>.</span></p>

<p>It is the ever so common case that you always hear, <q>It works fine here, it must be your fault.</q> And, boy did I come up with some interesting theories as to why it was not the fault of my code.</p>

<p>Basically, I'm POSTing some data to a resource that is protected by <a href="http://en.wikipedia.org/wiki/Basic_access_authentication">HTTP Basic Authentication</a>, and then reading the response for further processing. It is a basic task, and one that I've done many times in the past.</p>

<p>In fact, I've even used <code class="inline">urllib2</code> to do this before using the following method:</p>
<pre>
<code class="python">headers = {'User-Agent': useragent}
req = urllib2.Request(url, data, headers)
 
passmgr = urllib2.HTTPPasswordMgrWithDefaultRealm()
passmgr.add_password(None, url, username, passwd)
handler = urllib2.HTTPBasicAuthHandler(passmgr)
opener = urllib2.build_opener(handler)
connection = opener.open(req)
</code>
</pre>

<p>In this case, the following behavior is seen:</p>

<ol>
  <li>Client (urllib2) POSTs data leaving out the <code class="inline">Authorization</code> header</li>
  <li>Server responds with a <a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html#sec10.4.2">401</a>. Client (urllib2) never sees the 401 error, and instead gets a <a href="http://en.wikipedia.org/wiki/SIGPIPE">SIGPIPE</a></li>
  <li>Client attempts to reconnect, going right back to step 1</li>
</ol>

<p>Naturally, the only way I discovered this was to fire up <a href="http://en.wikipedia.org/wiki/Tcpdump">tcpdump</a> and look at what was being sent. It quickly became obvious that there was never an <code class="inline">Authorization</code> header being sent, and therefore the 401 was completely justified. The broken pipe seems to have come from the server responding before reading all of the posted data to thwart off <a href="http://en.wikipedia.org/wiki/Denial-of-service_attack">denial of service</a> attacks.</p>

<p>My only explanation for why this works perfectly fine on my laptop and not in either of the data centers I tried running it from is latency, though I'm shocked, and not yet convinced, by that result.</p>

<p>Incidentally, I solved the problem by sending the <code class="inline">Authorization</code> header on first request, rather than waiting for the confirmation that, yes indeed, the resource needs the Authorization header sent, as <code class="inline">urllib2</code> likes to do.</p>

<code class="python">headers = {'User-Agent': useragent, 
         'Authorization': 'Basic ' + base64.b64encode(username + ':' + passwd)}
req = urllib2.Request(url, data, headers)
connection = urllib2.urlopen(req)
</code>

<p>... and now it works fine.</p>

<p>This whole experience will make me think twice before laying the blame anywhere until I have uncovered the real truth, something I think all programmers should learn to do, if they don't know already.</p>
]]></content></entry>
<entry><title>The Case of the Unusable Reusable</title><link href="http://sigusr2.net/2009/Jul/22/case-of-the-unusable-reusable.html"/><id>md5:1790e770e90b7ed37ba8eeeda62034a7</id><updated>2009-07-22T00:00:00Z</updated><content type="html"><![CDATA[<p><span class="preamble">The <a href="http://www.djangoproject.com/">Django</a> web framework has a huge following that releases lots of simple reusable apps that can be plugged into your website. However, sometimes they are too simple, and not "plugin-able" quite enough.</span></p>

<p>Take for instance <a href="http://code.google.com/p/django-favorites/" title="django-favorites on Google Code">django-favorites</a>. By itself it's a great package that does exactly what you want&mdash;it allows a user to mark things as being a favorite. Notice that I said "things." "Things" here means any model, because it uses the <a href="http://docs.djangoproject.com/en/dev/ref/contrib/contenttypes/#id1" title="Generic Relations">generic relationships</a> framework that Django provides.</p>

<p>This is a huge win on its own because it means that I don't have to define a new favorites model for blog posts, one for photos and another for music I'm listening too. But, there's a downside to this as well.</p>

<p>How do I check to see if an item is a favorite? Well, for each blog post I select back from the database, I have to make another query to see whether or not it was a favorite or not. Alternatively, of course, I could be smarter and do a bulk query using an <code class="inline">IN</code> clause, making the query count only 2. But, if I wasn't using an <a href="http://en.wikipedia.org/wiki/Object-relational_mapping" title="Object Relational Mapper">ORM</a>, my SQL would use an <code class="inline">OUTER JOIN</code>, or a sub-query to select back whether or not it was marked a favorite for the current user.</p>

<p>Django can do this using the <a href="http://docs.djangoproject.com/en/dev/ref/models/querysets/#queryset-methods-that-return-new-querysets"><code class="inline">extra</code></a> method for <code class="inline">QuerySet</code>s.</p>

<p>Ok, so we can use <code class="inline">extra</code> every time we want to 
select back whether or not an item is a favorite, no big deal.</p>

<code class="python">content_type = ContentType.objects.get_for_model(Photo)
SQL = """SELECT 1 FROM favorites_favorite f
WHERE f.content_type_id = %(content_type)d and
      f.object_id = photos_photo.id and
      f.user_id = %(user_id)d
"""
attrs = {'content_type': content_type.id, 'user_id': user.id}
entries = Photo.objects.extra(select={'is_favorite': SQL % attrs})
</code>

<p>Except that you have to do this every time. So, you then create a custom manager for <code class="inline">Photo</code> that includes a <code class="inline">check_is_favorite</code> method, which adds the <code class="inline">is_favorite</code> pseudo-column and everything is good.</p>

<p>That is until you have to do it for <code class="inline">Entry</code>, and <code class="inline">Song</code>, and <code class="inline">User</code>.</p>

<p>The solution however is simple. Reusable apps should include a "ManagerMixin", if it makes sense to make reusing the app as painless as possible. The django-favorites application that I've been using in my example would be complete in my eyes if it had something like this defined in it:</p>

<code class="python">class FavoritesManagerMixin(object):
    """ A Mixin to add a `favorite__favorite` column via extra 
    """
    def with_favorite_for(self, user, all=True):
        """ Adds a column favorite__favorite to the returned object, which
        indicates whether or not this item is a favorite for a user
        """
        content_type = ContentType.objects.get_for_model(self.model)
        pk_field = "%s.%s" % (qn(self.model._meta.db_table),
                              qn(self.model._meta.pk.column))

        favorite_sql = """(SELECT 1 FROM %(favorites_db_table)s 
WHERE %(favorites_db_table)s.object_id = %(pk_field)s and
      %(favorites_db_table)s.content_type_id = %(content_type)d and
      %(favorites_db_table)s.user_id = %(user_id)d)
""" % {'pk_field': pk_field, \
           'db_table': qn(self.model._meta.db_table), \
           'favorites_db_table': qn(Favorite._meta.db_table), \
           'user_id': user.pk, \
           'content_type': content_type.id, \
           }

        extras = {
            'select': {'favorite__favorite': favorite_sql},
            }

        if not all:
            extras['where'] = ['favorite__favorite == 1']

        return self.extra(**extras)
</code>

<p>I have yet to run a bench mark against this to determine whether or not the sub-query here is less efficient than doing an <code class="inline">OUTER JOIN</code>. My gut says it would be, but for a first go at it, I'll keep it like this.</p>

<p>Anyway, then to make use of this you create a custom manager that uses <code class="inline">FavoritesManagerMixin</code> as one of its base classes:</p>

<code class="python">class SongManager(models.Manager, <strong>FavoritesMixinManager</strong>):
    pass

class Song(models.Model):
    title = models.CharField(max_length=255, null=False, blank=False)
    artist = models.ForeignKey('Artist')
    album = models.ForeignKey('Album')

    <strong>objects = SongManager()</strong>
</code>

<p>And then to make use of it, we do:</p>
<code class="python">all_songs_with_favorites_marked = Song.objects.with_favorite_for(user)
only_favorite_songs = Song.objects.with_favorite_for(user, all=False)
</code>

<p>The intention of this post isn't to point out a flaw in django-favorites, an otherwise great reusable application, BTW, but instead is meant to give a way that this idea of reusable can actually be usable.</p>

<p>I put my django-favorites on <a href="http://github.com/apgwoz/django-favorites/">github</a>. Feel free to flame me for going against what this post stands for and creating yet another "favorites" reusable app, without submitting a patch to the original, I wanted some practice in Django development.
</p>
]]></content></entry>
<entry><title>Dispatching With "with"</title><link href="http://sigusr2.net/2009/Mar/04/dispatching-with-with.html"/><id>md5:c47b741e6d7072c9b14a6d5f74c671f1</id><updated>2009-03-04T08:15:00Z</updated><content type="html"><![CDATA[<p>
<span class="preamble">Since <a href="http://www.python.org">Python</a> 2.5, we've had access to a new contstruct called the <a href="http://www.python.org/dev/peps/pep-0343/"><code class="inline">with</code></a>-statement. Using them is as simple as implementing the <a href="http://www.python.org/doc/2.5.2/lib/typecontextmanager.html">context manager protocol</a> for classes.
</span>
</p>

<p>The <code class="inline">with</code>-statement makes it possible to factor our <code class="inline">try</code>/<code class="inline">finally</code> statements that are commonly used to clean up resources created temporarily. Suppose for example, you have a multi-threaded application that makes use of mutexes to guard shared information. As a general rule, once you lock and perform the update on the shared variable, you need to unlock. Failure to unlock can lead to horrible problems, such as starvation or some other inconsistent state. 
</p>

<p>And, what happens if an exception occurs before you unlock? Quite frankly, you're out of luck unless you use <code class="inline">try</code>/<code class="inline">finally</code> to clean up regardless of what happens. It might look something like this:</p>

<code class="python">lock.lock()
try:
    # perform some action
finally:
    lock.unlock()
</code>

<p>This ensures that <code class="inline">lock</code> is unlocked after the action is performed.</p>

<p>Now, using the <code class="inline">with</code>-statement we get something more like:</p>
<code class="python">with lock:
    # perform some action
</code>

<p>The beauty is that we don't have to worry about remembering to call <code class="inline">unlock</code>, or wrap it up in the <code class="inline">try</code>/<code class="inline">finally</code> block. It does it for us.</p>

<p>But, we're not worried about locks here. We're interested in using <code class="inline">with</code> for another purpose, dispatching based on a requested url.</p>

<h3>URL Dispatching</h3>

<p>In many web frameworks these days for Python, such as <a href="http://webpy.org">web.py</a>, resources are dispatched to based on a regular expression that gets matched against the REQUEST_URI environment variable. This is normally pretty powerful, but in the case of web.py, the way this is specified is often a bit awkward. Take for instance:
</p>

<code class="python">import web

urls = (
    '/([a-zA-Z]*)', 'Hello'
)
app = web.application(urls, globals())

class Hello:
    def GET(self, name):
        if not name:
            name = 'world'
        return "Hello,", name

    def POST(self, name): # name can still be in the url
        i = web.input(name='world')
        return "You posted your name! Hello,", i.name

if __name__ == '__main__':
    app.run()
</code>

<p>which is a whole web application written in web.py. The awkwardness comes from the fact that the regular expression used for dispatch, is in no way connected to the resource itself. It'd be nice to use decorators for this so you could get something like:</p>

<code class="python">@web.expose('/([a-zA-Z]*)')
class Hello:
    ...
</code>

<p>but Python didn't get class decorators til Python 3.0, which many people aren't using yet, the author included. And what's the logic behind <code class="inline">def GET(<strong>self</strong>, ...)</code>? It's required in Python, but is just extraneous when defining a resource for web.py.</p>

<p>What if we implemented the context manager protocol in the object returned by <code class="inline">web.application()</code> above that looked like this (or something similiar):
</p>

<code class="python">import inspect
    --snip--
    def __enter__(self):
        return self

    def __exit__(self, *args):
        frame = inspect.currentframe()
        get = frame.f_back.f_locals.get('get', None)
        post = frame.f_back.f_locals.get('post', None)
        resource = {}
        if get:
            resource['get'] = get
        if post:
            resource['post'] = post

        if not (post or get):
            raise ValueError("with must have a get or post function")
        self._resources.append((re.compile(self._last_url), resource))

        if get:
            del frame.f_back.f_locals['get']
        if post:
            del frame.f_back.f_locals['post']

    def expose(self, url):
        self._last_url = url
        return self

    ...
</code>

<p>Then, the simple hello application instead looks like:</p>

<code class="python">import web

app = web.application()

with app.expose('/([a-zA-Z]*)'):
    def get(name):
        if not name:
            name = 'world'
        return "Hello,", name

    def post(name):
        i = web.input(name='world')
        return "You posted your name! Hello,", i.name

if __name__ == '__main__':
    app.run()
</code>

<p>It's declarative, simple, and eliminates a lot of noise, but we no longer get the packaging, or the ability to easily seperate our resources into multiple files. But, for one file web apps, maybe it's useful.</p>
]]></content></entry>
<entry><title>Anagrams Predicate</title><link href="http://sigusr2.net/2009/Jan/08/anagrams-predicate.html"/><id>md5:c7c123380fbc5a9934d6d485b0a050aa</id><updated>2009-01-08T00:00:00Z</updated><content type="html"><![CDATA[<p><span class="preamble">Recently, I spent some time thinking about a simple problem. How do you test if two strings are <a href="http://en.wikipedia.org/wiki/Anagram">anagrams</a> of each other?</span></p>

<p>There are many ways, but the naive solution is to simply sort both strings, character-wise, and then compare the results. In <a href="http://www.python.org">Python</a>, you might do that like so (We'll leave out the fact that anagrams are actually real words and phrases. We also work in a case-sensitive manor [e.g. "JimMorrison" and "MrMojoRisin" isn't truthy, though a simple <code class="inline">s.lower()</code> goes a long way.]):</p>

<code class="python">def isAnagram(str1, str2):
    if len(str1) != len(str2): return False
    return sorted(str1) == sorted(str2)
</code>

<p>Here, I'm using <code class="inline">sorted</code>, a Python <code class="inline">__builtin__</code>, that takes an iterable and produces a sorted list of that iterable. I'm then taking advantage of the fact that Python lists can be compared element-wise with the <code class="inline">==</code> operator. Doing this produces a function that will work on any string, and it's simple to see why. Sort the string "parental" and you get "aaelnprt." Sort the string "paternal" and you still get "aaelnprt." Obviously "aaelnprt" and "aaelnprt" are equivalent. This of course returns <code class="inline">False</code> for the strings "snowman" and "iceman" since they don't compare sorted equally (or non-sorted for that matter).</p>

<p>However, this solution isn't the most efficient use of resources. For one, most sorting algorithms are only <em>O(n log n)</em>, which means in the best case <code class="inline">isAnagram</code> is too. It also needs to allocate two lists to store the results returned by <code class="inline">sorted</code>.</p>

<p>There is of course a way to do better. You just have to think about the problem for a little longer than a minute:</p>

<code class="python">def isAnagramN(str1, str2):
    if len(str1) != len(str2): return False
    counts = defaultdict(lambda: [0, 0])

    for c1, c2 in izip(str1, str2):
        counts[c1][0] += 1
        counts[c2][1] += 1

    for k, v in counts.iteritems():
        if v[0] != v[1]:
            return False
    return True
</code>

<p>This code does not allocate proportionally to the size of the strings, but instead on the diversity of the strings. In other words, <code class="inline">isAnagramN("aaaaaaa", "bbbbbbb")</code> allocates 1 defaultdict, and 2 lists of size 2. Why? Because, the algorithm simply counts up how many times each letter occurs in each string. Of course Python also has to allocate the generators to use for <code class="inline">izip</code> and <code class="inline">counts.iteritems()</code>, but that isn't significant. The big win here of course is that given strings of <em>any</em> length, the algorithm uses only as much space as the diversity of the contents contained in the strings!</p>

<p>As if that wasn't a win enough, this algorithm runs in <em>O(n)</em> on the length of the strings!</p>

<p>But, does it actually make a difference? The answer of course is yes. For strings of significant length, <code class="inline">isAnagramN</code> runs almost 2x as fast as <code class="inline">isAnagram</code>.</p>

<p>The proof is in the bacon, so let's take a look at some numbers. Using Python's <code class="inline">timeit</code> module, I tested strings of length 1 through 100,001, incrementing by 10,000 (I've tested other lengths as well, and reach a similar conclusion). At each length, the test was repeated 50 times. The results are below:</p>

<style type="text/css">
td { text-align: right; }
td.win { background-color: #ADFF2F; font-weight: bold;}
td.first { background: #dddddd; font-weight: bold; color: #222222; }
</style>

<table cellspacing="5" style="margin: 0 auto;">
  <thead>
    <tr>
    <th>Length</th>
    <th>Time isAnagram</th>
    <th>Time isAnagramN</th>
    </tr>
  </thead>
  <tbody>
    <tr>
     <td class="first">1</td><td class="win">0.00043511390686</td><td>0.000530958175659</td>
     </tr>
     <tr>
     <td class="first">10001</td><td>0.657309055328</td><td class="win">0.38395690918</td>
     </tr>
     <tr>
     <td class="first">20001</td><td>1.25437283516</td><td class="win">0.793761968613</td>
     </tr>
     <tr>
     <td class="first">30001</td><td>1.91431283951</td><td class="win">1.15374517441</td>
     </tr>
     <tr>
     <td class="first">40001</td><td>2.55181908607</td><td class="win">1.53560996056</td>
     </tr>
     <tr>
     <td class="first">50001</td><td>3.14615797997</td><td class="win">2.07976388931</td>
     </tr>
     <tr>
     <td class="first">60001</td><td>3.76745486259</td><td class="win">2.30041193962</td>
     </tr>
     <tr>
     <td class="first">70001</td><td>4.48913788795</td><td class="win">2.81828999519</td>
     </tr>
     <tr>
     <td class="first">80001</td><td>5.155148983</td><td class="win">3.09482097626</td>
     </tr>
     <tr>
     <td class="first">90001</td><td>5.67185592651</td><td class="win">3.477850914</td>
     </tr>
     <tr>
     <td class="first">100001</td><td>6.33614587784</td><td class="win">3.94285678864</td>
     </tr>
  </tbody>
</table>

<p>
  Download the code: <a href="http://files.sigusr2.net/anagram.py">anagram.py</a>
</p>
]]></content></entry>

</feed>